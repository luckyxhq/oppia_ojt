// Copyright 2025 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for new Conversation skin component.
 */

import {HttpClientTestingModule} from '@angular/common/http/testing';
import {EventEmitter, NO_ERRORS_SCHEMA} from '@angular/core';
import {
  ComponentFixture,
  fakeAsync,
  TestBed,
  tick,
  waitForAsync,
  flush,
  flushMicrotasks,
} from '@angular/core/testing';
import {TranslateService} from '@ngx-translate/core';
import {MockTranslateService} from '../../../../components/forms/schema-based-editors/integration-tests/schema-based-editors.integration.spec';
import {Collection} from '../../../../domain/collection/collection.model';
import {GuestCollectionProgressService} from '../../../../domain/collection/guest-collection-progress.service';
import {ReadOnlyCollectionBackendApiService} from '../../../../domain/collection/read-only-collection-backend-api.service';
import {Interaction} from '../../../../domain/exploration/interaction.model';
import {StateObjectFactory} from '../../../../domain/state/StateObjectFactory';
import {CheckpointProgressService} from '../../services/checkpoint-progress.service';
import {
  FetchExplorationBackendResponse,
  ReadOnlyExplorationBackendApiService,
} from '../../../../domain/exploration/read-only-exploration-backend-api.service';
import {StateCard} from '../../../../domain/state_card/state-card.model';
import {ReadOnlyStoryNode} from '../../../../domain/story_viewer/read-only-story-node.model';
import {StoryPlaythrough} from '../../../../domain/story_viewer/story-playthrough.model';
import {StoryViewerBackendApiService} from '../../../../domain/story_viewer/story-viewer-backend-api.service';
import {UserInfo} from '../../../../domain/user/user-info.model';
import {UrlInterpolationService} from '../../../../domain/utilities/url-interpolation.service';
import {CollectionPlayerBackendApiService} from '../../../../pages/collection-player-page/services/collection-player-backend-api.service';
import {AlertsService} from '../../../../services/alerts.service';
import {AudioPlayerService} from '../../../../services/audio-player.service';
import {AutogeneratedAudioPlayerService} from '../../../../services/autogenerated-audio-player.service';
import {PageContextService} from '../../../../services/page-context.service';
import {DiagnosticTestPlayerEngineService} from '../../services/diagnostic-test-player-engine.service';
import {UrlService} from '../../../../services/contextual/url.service';
import {WindowDimensionsService} from '../../../../services/contextual/window-dimensions.service';
import {WindowRef} from '../../../../services/contextual/window-ref.service';
import {I18nLanguageCodeService} from '../../../../services/i18n-language-code.service';
import {LoaderService} from '../../../../services/loader.service';
import {LocalStorageService} from '../../../../services/local-storage.service';
import {MessengerService} from '../../../../services/messenger.service';
import {FocusManagerService} from '../../../../services/stateful/focus-manager.service';
import {UserService} from '../../../../services/user.service';
import {MockTranslatePipe} from '../../../../tests/unit-test-utils';
import {ExplorationPlayerConstants} from '../../current-lesson-player/exploration-player-page.constants';
import {ContentTranslationManagerService} from '../../services/content-translation-manager.service';
import {CurrentInteractionService} from '../../services/current-interaction.service';
import {ExplorationEngineService} from '../../services/exploration-engine.service';
import {ExplorationModeService} from '../../services/exploration-mode.service';
import {ExplorationRecommendationsService} from '../../services/exploration-recommendations.service';
import {HintsAndSolutionManagerService} from '../../services/hints-and-solution-manager.service';
import {ImagePreloaderService} from '../../services/image-preloader.service';
import {LearnerAnswerInfoService} from '../../services/learner-answer-info.service';
import {LearnerParamsService} from '../../services/learner-params.service';
import {PlayerPositionService} from '../../services/player-position.service';
import {PlayerTranscriptService} from '../../services/player-transcript.service';
import {QuestionPlayerEngineService} from '../../services/question-player-engine.service';
import {StatsReportingService} from '../../services/stats-reporting.service';
import {ExplorationInitializationService} from '../../services/exploration-initialization.service';
import {NewConversationSkinComponent} from './new-conversation-skin.component';
import {LearnerDashboardBackendApiService} from '../../../../domain/learner_dashboard/learner-dashboard-backend-api.service';
import {EditableExplorationBackendApiService} from '../../../../domain/exploration/editable-exploration-backend-api.service';
import {DiagnosticTestTopicTrackerModel} from '../../../../pages/diagnostic-test-player-page/diagnostic-test-topic-tracker.model';
import {ConceptCardManagerService} from '../../services/concept-card-manager.service';
import {Solution} from '../../../../domain/exploration/solution.model';
import {ConversationFlowService} from '../../services/conversation-flow.service';
import {CurrentEngineService} from '../../services/current-engine.service';
import {LearnerExplorationSummary} from '../../../../domain/summary/learner-exploration-summary.model';
import {ChapterProgressService} from '../../services/chapter-progress.service';
import {CardAnimationService} from '../../services/card-animation.service';
class MockWindowRef {
  nativeWindow = {
    location: {
      pathname: '/path/name',
      reload: () => {},
    },
    onresize: () => {},
    addEventListener(event: string, callback) {
      callback({returnValue: null});
    },
    scrollTo: (x, y) => {},
  };
}

describe('Conversation skin component', () => {
  let fixture: ComponentFixture<NewConversationSkinComponent>;
  let componentInstance: NewConversationSkinComponent;
  let chapterProgressService: ChapterProgressService;
  let cardAnimationService: CardAnimationService;
  let alertsService: AlertsService;
  let audioPlayerService: AudioPlayerService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let collectionPlayerBackendApiService: CollectionPlayerBackendApiService;
  let contentTranslationManagerService: ContentTranslationManagerService;
  let pageContextService: PageContextService;
  let conversationFlowService: ConversationFlowService;
  let currentInteractionService: CurrentInteractionService;
  let editableExplorationBackendApiService: EditableExplorationBackendApiService;
  let explorationEngineService: ExplorationEngineService;
  let explorationModeService: ExplorationModeService;
  let explorationRecommendationsService: ExplorationRecommendationsService;
  let focusManagerService: FocusManagerService;
  let explorationInitializationService: ExplorationInitializationService;
  let guestCollectionProgressService: GuestCollectionProgressService;
  let hintsAndSolutionManagerService: HintsAndSolutionManagerService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let imagePreloaderService: ImagePreloaderService;
  let learnerAnswerInfoService: LearnerAnswerInfoService;
  let diagnosticTestPlayerEngineService: DiagnosticTestPlayerEngineService;
  let learnerParamsService: LearnerParamsService;
  let loaderService: LoaderService;
  let localStorageService: LocalStorageService;
  let messengerService: MessengerService;
  let playerPositionService: PlayerPositionService;
  let playerTranscriptService: PlayerTranscriptService;
  let questionPlayerEngineService: QuestionPlayerEngineService;
  let readOnlyCollectionBackendApiService: ReadOnlyCollectionBackendApiService;
  let statsReportingService: StatsReportingService;
  let storyViewerBackendApiService: StoryViewerBackendApiService;
  let urlInterpolationService: UrlInterpolationService;
  let urlService: UrlService;
  let currentEngineService: CurrentEngineService;
  let stateObjectFactory: StateObjectFactory;
  let userService: UserService;
  let windowDimensionsService: WindowDimensionsService;
  let checkpointProgressService: CheckpointProgressService;
  let windowRef: WindowRef;
  let readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService;
  let translateService: TranslateService;
  let learnerDashboardBackendApiService: LearnerDashboardBackendApiService;
  let conceptCardManagerService: ConceptCardManagerService;

  let displayedCard = new StateCard(
    null,
    null,
    null,
    new Interaction([], [], null, null, [], '', null),
    [],
    '',
    null
  );

  let explorationDict = {
    states: {
      Start: {
        classifier_model_id: null,
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'TextInput',
          hints: [],
          customization_args: {
            rows: {
              value: 1,
            },
            placeholder: {
              value: {
                unicode_str: '',
                content_id: 'ca_placeholder_0',
              },
            },
            catchMisspellings: {
              value: false,
            },
          },
          answer_groups: [
            {
              outcome: {
                missing_prerequisite_skill_id: null,
                refresher_exploration_id: null,
                labelled_as_correct: false,
                feedback: {
                  content_id: 'feedback_1',
                  html: '<p>Good Job</p>',
                },
                param_changes: [],
                dest_if_really_stuck: null,
                dest: 'Mid',
              },
              training_data: [],
              rule_specs: [
                {
                  inputs: {
                    x: {
                      normalizedStrSet: ['answer'],
                      contentId: 'rule_input_2',
                    },
                  },
                  rule_type: 'FuzzyEquals',
                },
              ],
              tagged_skill_misconception_id: null,
            },
          ],
          default_outcome: {
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            labelled_as_correct: false,
            feedback: {
              content_id: 'default_outcome',
              html: '<p>Try again.</p>',
            },
            param_changes: [],
            dest_if_really_stuck: null,
            dest: 'Start',
          },
        },
        param_changes: [],
        card_is_checkpoint: true,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: '<p>First Question</p>',
        },
      },
      End: {
        classifier_model_id: null,
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'EndExploration',
          hints: [],
          customization_args: {
            recommendedExplorationIds: {
              value: ['recommnendedExplorationId'],
            },
          },
          answer_groups: [],
          default_outcome: null,
        },
        param_changes: [],
        card_is_checkpoint: false,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: 'Congratulations, you have finished!',
        },
      },
      Mid: {
        classifier_model_id: null,
        solicit_answer_details: false,
        interaction: {
          solution: null,
          confirmed_unclassified_answers: [],
          id: 'TextInput',
          hints: [],
          customization_args: {
            rows: {
              value: 1,
            },
            placeholder: {
              value: {
                unicode_str: '',
                content_id: 'ca_placeholder_0',
              },
            },
            catchMisspellings: {
              value: false,
            },
          },
          answer_groups: [
            {
              outcome: {
                missing_prerequisite_skill_id: null,
                refresher_exploration_id: null,
                labelled_as_correct: false,
                feedback: {
                  content_id: 'feedback_1',
                  html: ' <p>Good Job</p>',
                },
                param_changes: [],
                dest_if_really_stuck: null,
                dest: 'End',
              },
              training_data: [],
              rule_specs: [
                {
                  inputs: {
                    x: {
                      normalizedStrSet: ['answer'],
                      contentId: 'rule_input_2',
                    },
                  },
                  rule_type: 'FuzzyEquals',
                },
              ],
              tagged_skill_misconception_id: null,
            },
          ],
          default_outcome: {
            missing_prerequisite_skill_id: null,
            refresher_exploration_id: null,
            labelled_as_correct: false,
            feedback: {
              content_id: 'default_outcome',
              html: '<p>try again.</p>',
            },
            param_changes: [],
            dest_if_really_stuck: null,
            dest: 'Mid',
          },
        },
        param_changes: [],
        card_is_checkpoint: false,
        linked_skill_id: null,
        content: {
          content_id: 'content',
          html: '<p>Second Question</p>',
        },
      },
    },
    auto_tts_enabled: true,
    version: 2,
    draft_change_list_id: 9,
    is_version_of_draft_valid: null,
    title: 'Exploration',
    language_code: 'en',
    init_state_name: 'Start',
    param_changes: [],
    next_content_id_index: 4,
    param_specs: null,
    draft_changes: null,
  };

  let explorationResponse: FetchExplorationBackendResponse = {
    exploration_id: 'exp_id',
    is_logged_in: true,
    session_id: 'KERH',
    displayable_language_codes: [],
    exploration: {
      init_state_name: 'Start',
      param_changes: [],
      param_specs: null,
      title: 'Exploration',
      language_code: 'en',
      objective: 'To learn',
      states: explorationDict.states,
      next_content_id_index: explorationDict.next_content_id_index,
    },
    exploration_metadata: {
      title: 'Exploration',
      category: 'Algebra',
      objective: 'To learn',
      language_code: 'en',
      tags: [],
      blurb: '',
      author_notes: '',
      states_schema_version: 50,
      init_state_name: 'Introduction',
      param_specs: {},
      param_changes: [],
      auto_tts_enabled: false,
      edits_allowed: true,
    },
    version: 2,
    can_edit: true,
    preferred_audio_language_code: 'en',
    preferred_language_codes: [],
    auto_tts_enabled: true,
    record_playthrough_probability: 1,
    draft_change_list_id: 0,
    has_viewed_lesson_info_modal_once: false,
    furthest_reached_checkpoint_exp_version: 1,
    furthest_reached_checkpoint_state_name: 'End',
    most_recently_reached_checkpoint_state_name: 'Mid',
    most_recently_reached_checkpoint_exp_version: 2,
  };

  let sampleExpResponse: FetchExplorationBackendResponse = {
    exploration_id: 'exp_id',
    is_logged_in: true,
    session_id: 'KERH',
    displayable_language_codes: [],
    exploration: {
      init_state_name: 'Start',
      param_changes: [],
      param_specs: null,
      title: 'Exploration',
      language_code: 'en',
      objective: 'To learn',
      states: explorationDict.states,
      next_content_id_index: explorationDict.next_content_id_index,
    },
    exploration_metadata: {
      title: 'Exploration',
      category: 'Algebra',
      objective: 'To learn',
      language_code: 'en',
      tags: [],
      blurb: '',
      author_notes: '',
      states_schema_version: 50,
      init_state_name: 'Introduction',
      param_specs: {},
      param_changes: [],
      auto_tts_enabled: false,
      edits_allowed: true,
    },
    version: 2,
    can_edit: true,
    preferred_audio_language_code: 'en',
    preferred_language_codes: [],
    auto_tts_enabled: true,
    record_playthrough_probability: 1,
    draft_change_list_id: 0,
    has_viewed_lesson_info_modal_once: false,
    furthest_reached_checkpoint_exp_version: 1,
    furthest_reached_checkpoint_state_name: 'End',
    most_recently_reached_checkpoint_state_name: null,
    most_recently_reached_checkpoint_exp_version: 2,
  };
  let uniqueProgressIdResponse = '123456';

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      declarations: [NewConversationSkinComponent, MockTranslatePipe],
      providers: [
        {
          provide: WindowRef,
          useClass: MockWindowRef,
        },
        {
          provide: TranslateService,
          useClass: MockTranslateService,
        },
      ],
      schemas: [NO_ERRORS_SCHEMA],
    }).compileComponents();

    fixture = TestBed.createComponent(NewConversationSkinComponent);
    componentInstance = fixture.componentInstance;

    alertsService = TestBed.inject(AlertsService);
    stateObjectFactory = TestBed.inject(StateObjectFactory);
    audioPlayerService = TestBed.inject(AudioPlayerService);
    checkpointProgressService = TestBed.inject(CheckpointProgressService);
    autogeneratedAudioPlayerService = TestBed.inject(
      AutogeneratedAudioPlayerService
    );
    collectionPlayerBackendApiService = TestBed.inject(
      CollectionPlayerBackendApiService
    );
    cardAnimationService = TestBed.inject(CardAnimationService);
    contentTranslationManagerService = TestBed.inject(
      ContentTranslationManagerService
    );
    pageContextService = TestBed.inject(PageContextService);
    conversationFlowService = TestBed.inject(ConversationFlowService);
    currentInteractionService = TestBed.inject(CurrentInteractionService);
    editableExplorationBackendApiService = TestBed.inject(
      EditableExplorationBackendApiService
    );
    chapterProgressService = TestBed.inject(ChapterProgressService);
    explorationEngineService = TestBed.inject(ExplorationEngineService);
    explorationModeService = TestBed.inject(ExplorationModeService);
    explorationRecommendationsService = TestBed.inject(
      ExplorationRecommendationsService
    );
    diagnosticTestPlayerEngineService = TestBed.inject(
      DiagnosticTestPlayerEngineService
    );
    focusManagerService = TestBed.inject(FocusManagerService);
    guestCollectionProgressService = TestBed.inject(
      GuestCollectionProgressService
    );
    hintsAndSolutionManagerService = TestBed.inject(
      HintsAndSolutionManagerService
    );
    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);
    imagePreloaderService = TestBed.inject(ImagePreloaderService);
    learnerAnswerInfoService = TestBed.inject(LearnerAnswerInfoService);
    explorationInitializationService = TestBed.inject(
      ExplorationInitializationService
    );
    currentEngineService = TestBed.inject(CurrentEngineService);
    learnerParamsService = TestBed.inject(LearnerParamsService);
    loaderService = TestBed.inject(LoaderService);
    localStorageService = TestBed.inject(LocalStorageService);
    messengerService = TestBed.inject(MessengerService);
    playerPositionService = TestBed.inject(PlayerPositionService);
    playerTranscriptService = TestBed.inject(PlayerTranscriptService);
    questionPlayerEngineService = TestBed.inject(QuestionPlayerEngineService);
    readOnlyCollectionBackendApiService = TestBed.inject(
      ReadOnlyCollectionBackendApiService
    );
    statsReportingService = TestBed.inject(StatsReportingService);
    storyViewerBackendApiService = TestBed.inject(StoryViewerBackendApiService);
    urlInterpolationService = TestBed.inject(UrlInterpolationService);
    urlService = TestBed.inject(UrlService);
    userService = TestBed.inject(UserService);
    windowDimensionsService = TestBed.inject(WindowDimensionsService);
    windowRef = TestBed.inject(WindowRef);
    readOnlyExplorationBackendApiService = TestBed.inject(
      ReadOnlyExplorationBackendApiService
    );
    conceptCardManagerService = TestBed.inject(ConceptCardManagerService);
    translateService = TestBed.inject(TranslateService);
    learnerDashboardBackendApiService = TestBed.inject(
      LearnerDashboardBackendApiService
    );
  }));

  it('should initialize component', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isIframed = true;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true,
    };
    let newStateName = 'newState';
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
      collectionId,
      null
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(
      readOnlyCollectionBackendApiService,
      'loadCollectionAsync'
    ).and.returnValue(
      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
    );
    spyOn(pageContextService, 'getExplorationId').and.returnValue(expId);
    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
      explorationEngineService
    );
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      'oppia_avatar_url'
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValues(
      true,
      false
    );
    spyOn(componentInstance, 'initializePage');
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.resolve(collectionSummary));
    spyOn(questionPlayerEngineService, 'recordHintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerEngineService, 'recordSolutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(chapterProgressService, 'updateCompletedChaptersCount');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService,
      'recordExplorationCompletedInCollection'
    );
    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(conversationFlowService, 'setNextStateCard').and.callThrough();
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(explorationResponse));
    spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue([
      'Start',
      'Mid',
    ]);
    spyOn(
      editableExplorationBackendApiService,
      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'
    ).and.returnValue(
      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})
    );
    spyOn(conversationFlowService, 'triggerIfLearnerStuckAction').and.callFake(
      (isStuck: boolean, callback: () => void) => {
        callback();
      }
    );

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
      mockOnNewCardOpened
    );
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintsExhausted'
    ).and.returnValue(mockOnHintsExhausted);
    spyOnProperty(
      conceptCardManagerService,
      'onLearnerGetsReallyStuck'
    ).and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onLearnerReallyStuck'
    ).and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintConsumed'
    ).and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onSolutionViewedEventEmitter'
    ).and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(
      conversationFlowService,
      'onPlayerStateChange'
    ).and.returnValue(mockOnPlayerStateChange);

    const nextCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      '',
      null
    );
    conversationFlowService.setNextStateCard(nextCard);
    componentInstance.isLoggedIn = false;
    conversationFlowService.setHasInteractedAtLeastOnce(true);
    conversationFlowService.setDisplayedCard(displayedCard);
    conversationFlowService.setExplorationActuallyStarted(false);

    componentInstance.ngOnInit();
    tick();
    windowRef.nativeWindow.onresize(null);

    mockOnNewCardOpened.emit(conversationFlowService.getNextStateCard());
    mockOnHintsExhausted.emit();
    mockOnLearnerGetsReallyStuck.emit();
    mockOnLearnerReallyStuck.emit();
    mockOnHintConsumed.emit();
    mockOnSolutionViewedEventEmitter.emit();
    mockOnPlayerStateChange.emit();
    mockOnPlayerStateChange.emit(newStateName);
    tick(100);

    expect(componentInstance.continueToReviseStateButtonIsVisible).toBeTrue();
    conversationFlowService.setRedirectToRefresherExplorationConfirmed(true);

    spyOn(alertsService, 'addWarning');
    componentInstance.ngOnInit();

    windowRef.nativeWindow.onresize(null);
    tick(1000);
  }));

  it('should initialize component as logged in user', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isIframed = false;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true,
    };
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
      collectionId,
      null
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(
      readOnlyCollectionBackendApiService,
      'loadCollectionAsync'
    ).and.returnValue(
      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
    );
    spyOn(
      chapterProgressService,
      'updateCompletedChaptersCount'
    ).and.callThrough();
    spyOn(
      learnerDashboardBackendApiService,
      'fetchLearnerCompletedChaptersCountDataAsync'
    ).and.returnValue(
      Promise.resolve({
        completedChaptersCount: 1,
      })
    );
    spyOn(pageContextService, 'getExplorationId').and.returnValue(expId);
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      'oppia_avatar_url'
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValues(
      true,
      false
    );
    spyOn(componentInstance, 'initializePage');
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.resolve(collectionSummary));
    spyOn(questionPlayerEngineService, 'recordHintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerEngineService, 'recordSolutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService,
      'recordExplorationCompletedInCollection'
    );

    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(sampleExpResponse));

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
      mockOnNewCardOpened
    );
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintsExhausted'
    ).and.returnValue(mockOnHintsExhausted);
    spyOnProperty(
      conceptCardManagerService,
      'onLearnerGetsReallyStuck'
    ).and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onLearnerReallyStuck'
    ).and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintConsumed'
    ).and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onSolutionViewedEventEmitter'
    ).and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(
      conversationFlowService,
      'onPlayerStateChange'
    ).and.returnValue(mockOnPlayerStateChange);

    const nextCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      '',
      null
    );
    conversationFlowService.setNextStateCard(nextCard);
    componentInstance.isLoggedIn = true;
    componentInstance.isIframed = false;
    conversationFlowService.setHasInteractedAtLeastOnce(true);
    conversationFlowService.setDisplayedCard(displayedCard);

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    // Tick has been used here because
    // the windowRef.nativeWindow.onresize function
    // calls adjustPageHeight function where we have used setTimeout
    // for 100 sec by making tick(100) we make sure setTimout code calls.
    tick(100);
  }));

  it('should initialize component as logged out user', fakeAsync(() => {
    let collectionId = 'id';
    let expId = 'exp_id';
    let isIframed = false;
    let collectionSummary = {
      is_admin: true,
      summaries: [],
      user_email: '',
      is_topic_manager: false,
      username: true,
    };
    let expResponse = sampleExpResponse;
    expResponse.is_logged_in = false;
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', false)
      )
    );
    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
      collectionId,
      null
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

    spyOn(
      readOnlyCollectionBackendApiService,
      'loadCollectionAsync'
    ).and.returnValue(
      Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
    );
    spyOn(pageContextService, 'getExplorationId').and.returnValue(expId);
    spyOn(urlService, 'isIframed').and.returnValue(isIframed);
    spyOn(loaderService, 'showLoadingScreen');
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      'oppia_avatar_url'
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValues(
      true,
      false
    );
    spyOn(componentInstance, 'initializePage');
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(Promise.resolve(collectionSummary));
    spyOn(questionPlayerEngineService, 'recordHintUsed');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(questionPlayerEngineService, 'recordSolutionViewed');
    spyOn(imagePreloaderService, 'onStateChange');
    spyOn(chapterProgressService, 'updateCompletedChaptersCount');
    spyOn(statsReportingService, 'recordExplorationCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(
      guestCollectionProgressService,
      'recordExplorationCompletedInCollection'
    );

    spyOn(statsReportingService, 'recordMaybeLeaveEvent');
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
    spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
    spyOn(messengerService, 'sendMessage');
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(expResponse));
    spyOn(
      editableExplorationBackendApiService,
      'recordProgressAndFetchUniqueProgressIdOfLoggedOutLearner'
    ).and.returnValue(
      Promise.resolve({unique_progress_url_id: uniqueProgressIdResponse})
    );

    let mockOnHintConsumed = new EventEmitter();
    let mockOnSolutionViewedEventEmitter = new EventEmitter();
    let mockOnPlayerStateChange = new EventEmitter();
    let mockOnNewCardOpened = new EventEmitter();
    let mockOnHintsExhausted = new EventEmitter();
    let mockOnLearnerReallyStuck = new EventEmitter();
    let mockOnLearnerGetsReallyStuck = new EventEmitter();

    spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
      mockOnNewCardOpened
    );
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintsExhausted'
    ).and.returnValue(mockOnHintsExhausted);
    spyOnProperty(
      conceptCardManagerService,
      'onLearnerGetsReallyStuck'
    ).and.returnValue(mockOnLearnerGetsReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onLearnerReallyStuck'
    ).and.returnValue(mockOnLearnerReallyStuck);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onHintConsumed'
    ).and.returnValue(mockOnHintConsumed);
    spyOnProperty(
      hintsAndSolutionManagerService,
      'onSolutionViewedEventEmitter'
    ).and.returnValue(mockOnSolutionViewedEventEmitter);
    spyOnProperty(
      conversationFlowService,
      'onPlayerStateChange'
    ).and.returnValue(mockOnPlayerStateChange);

    const nextCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      '',
      null
    );
    conversationFlowService.setNextStateCard(nextCard);
    componentInstance.isLoggedIn = false;
    componentInstance.isIframed = false;
    conversationFlowService.setHasInteractedAtLeastOnce(true);
    conversationFlowService.setDisplayedCard(displayedCard);

    componentInstance.ngOnInit();
    windowRef.nativeWindow.onresize(null);

    // Tick has been used here because
    // the windowRef.nativeWindow.onresize function
    // calls adjustPageHeight function where we have used setTimeout
    // for 100 sec by making tick(100) we make sure setTimout code calls.
    tick(100);
  }));

  it(
    'should convert logged out progress to logged in progress when user ' +
      'signs in',
    fakeAsync(() => {
      let collectionId = 'id';
      let expId = 'exp_id';
      let isIframed = false;
      let collectionSummary = {
        is_admin: true,
        summaries: [],
        user_email: '',
        is_topic_manager: false,
        username: true,
      };
      spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
        false
      );
      spyOn(userService, 'getUserInfoAsync').and.returnValue(
        Promise.resolve(
          new UserInfo([], false, false, false, false, false, '', '', '', true)
        )
      );
      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValues(
        collectionId,
        null
      );
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);

      spyOn(
        readOnlyCollectionBackendApiService,
        'loadCollectionAsync'
      ).and.returnValue(
        Promise.resolve(new Collection('', '', '', '', [], null, '', 6, 8, []))
      );
      spyOn(pageContextService, 'getExplorationId').and.returnValue(expId);
      spyOn(urlService, 'isIframed').and.returnValue(isIframed);
      spyOn(loaderService, 'showLoadingScreen');
      spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
        'oppia_avatar_url'
      );
      spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValues(
        true,
        false
      );
      spyOn(componentInstance, 'initializePage');
      spyOn(
        collectionPlayerBackendApiService,
        'fetchCollectionSummariesAsync'
      ).and.returnValue(Promise.resolve(collectionSummary));
      spyOn(questionPlayerEngineService, 'recordHintUsed');
      spyOn(questionPlayerEngineService, 'getCurrentQuestion');
      spyOn(questionPlayerEngineService, 'recordSolutionViewed');
      spyOn(imagePreloaderService, 'onStateChange');
      spyOn(statsReportingService, 'recordExplorationCompleted');
      spyOn(statsReportingService, 'recordExplorationActuallyStarted');
      spyOn(
        guestCollectionProgressService,
        'recordExplorationCompletedInCollection'
      );

      spyOn(statsReportingService, 'recordMaybeLeaveEvent');
      spyOn(playerTranscriptService, 'getLastStateName').and.returnValue('');
      spyOn(learnerParamsService, 'getAllParams').and.returnValue({});
      spyOn(messengerService, 'sendMessage');
      spyOn(
        readOnlyExplorationBackendApiService,
        'loadLatestExplorationAsync'
      ).and.returnValue(Promise.resolve(sampleExpResponse));
      spyOn(
        editableExplorationBackendApiService,
        'changeLoggedOutProgressToLoggedInProgressAsync'
      ).and.returnValue(Promise.resolve());

      let mockOnHintConsumed = new EventEmitter();
      let mockOnSolutionViewedEventEmitter = new EventEmitter();
      let mockOnPlayerStateChange = new EventEmitter();
      let mockOnNewCardOpened = new EventEmitter();
      let mockOnHintsExhausted = new EventEmitter();
      let mockOnLearnerReallyStuck = new EventEmitter();
      let mockOnLearnerGetsReallyStuck = new EventEmitter();

      spyOnProperty(playerPositionService, 'onNewCardOpened').and.returnValue(
        mockOnNewCardOpened
      );
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onHintsExhausted'
      ).and.returnValue(mockOnHintsExhausted);
      spyOnProperty(
        conceptCardManagerService,
        'onLearnerGetsReallyStuck'
      ).and.returnValue(mockOnLearnerGetsReallyStuck);
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onLearnerReallyStuck'
      ).and.returnValue(mockOnLearnerReallyStuck);
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onHintConsumed'
      ).and.returnValue(mockOnHintConsumed);
      spyOnProperty(
        hintsAndSolutionManagerService,
        'onSolutionViewedEventEmitter'
      ).and.returnValue(mockOnSolutionViewedEventEmitter);
      spyOnProperty(
        conversationFlowService,
        'onPlayerStateChange'
      ).and.returnValue(mockOnPlayerStateChange);
      spyOn(
        localStorageService,
        'getUniqueProgressIdOfLoggedOutLearner'
      ).and.returnValue('abcdef');
      spyOn(localStorageService, 'removeUniqueProgressIdOfLoggedOutLearner');

      const nextCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        '',
        null
      );
      conversationFlowService.setNextStateCard(nextCard);
      componentInstance.isLoggedIn = true;
      componentInstance.isIframed = false;
      conversationFlowService.setHasInteractedAtLeastOnce(true);
      conversationFlowService.setDisplayedCard(displayedCard);

      componentInstance.ngOnInit();
      tick(100);

      expect(
        editableExplorationBackendApiService.changeLoggedOutProgressToLoggedInProgressAsync
      ).toHaveBeenCalled();
      expect(
        localStorageService.removeUniqueProgressIdOfLoggedOutLearner
      ).toHaveBeenCalled();
    })
  );

  it('should show alert when collection summaries are not loaded', fakeAsync(() => {
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      true
    );
    spyOn(pageContextService, 'getExplorationId').and.returnValue('exp_id');

    spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(
      'collection_id'
    );
    spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
    spyOn(
      localStorageService,
      'getUniqueProgressIdOfLoggedOutLearner'
    ).and.returnValue(null);
    spyOn(
      collectionPlayerBackendApiService,
      'fetchCollectionSummariesAsync'
    ).and.returnValue(
      Promise.reject(
        'There was an error while fetching the collection summary.'
      )
    );
    spyOn(alertsService, 'addWarning');

    componentInstance.ngOnInit();
    flushMicrotasks();

    expect(pageContextService.isInExplorationEditorPage).toHaveBeenCalled();
    expect(urlService.getCollectionIdFromExplorationUrl).toHaveBeenCalled();
    expect(
      collectionPlayerBackendApiService.fetchCollectionSummariesAsync
    ).toHaveBeenCalled();
    expect(alertsService.addWarning).toHaveBeenCalledWith(
      'There was an error while fetching the collection summary.'
    );
  }));

  it('should tell if submit button is disabled', () => {
    let displayedCardIndex = 1;
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      displayedCardIndex
    );
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(currentInteractionService, 'isSubmitButtonDisabled').and.returnValue(
      true
    );

    expect(componentInstance.isSubmitButtonDisabled()).toBeTrue();
    expect(componentInstance.isSubmitButtonDisabled()).toBeFalse();
  });

  it(
    'should release solution when the learner gets stuck' +
      ' if no stuck state exists after a predetermined time',
    fakeAsync(() => {
      // Release solution if stuck state is null.
      conversationFlowService.setNextCardIfStuck(null);
      let solutionSpy = spyOn(
        hintsAndSolutionManagerService,
        'releaseSolution'
      );
      let redirectionSpy = spyOn(conversationFlowService, 'showUpcomingCard');
      const solutionForState = Solution.createNew(
        true,
        'answer',
        'Html',
        'XyzID'
      );
      conversationFlowService.setSolutionForState(solutionForState);
      for (let index = 0; index < 3; index++) {
        playerTranscriptService.incrementNumberOfIncorrectSubmissions();
      }
      conversationFlowService.triggerIfLearnerStuckAction(true, () => {
        componentInstance.continueToReviseStateButtonIsVisible = true;
      });
      tick(
        ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC
      );
      tick(ExplorationPlayerConstants.WAIT_BEFORE_REALLY_STUCK_MSEC);

      expect(solutionSpy).toHaveBeenCalled();
      expect(redirectionSpy).not.toHaveBeenCalled();
      flush();
    })
  );

  it(
    'should direct the learner to the stuck' +
      ' when the learner gets stuck and such a state exists after a' +
      ' predetermined time',
    fakeAsync(() => {
      spyOn(conversationFlowService, 'showPendingCard');
      spyOn(translateService, 'instant').and.callThrough();
      spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');

      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(
        false
      );
      const nextCardIfStuck = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        '',
        null
      );

      conversationFlowService.setNextCardIfStuck(nextCardIfStuck);
      conversationFlowService.triggerIfLearnerStuckAction(true, () => {
        componentInstance.continueToReviseStateButtonIsVisible = true;
      });
      tick(
        ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC
      );

      expect(translateService.instant).toHaveBeenCalledWith(
        'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE'
      );

      expect(componentInstance.continueToReviseStateButtonIsVisible).toBeTrue();
      flush();
    })
  );

  it(
    'should immediately release solution when the learner gets stuck' +
      ' if no stuck state exists',
    fakeAsync(() => {
      // Release solution if stuck state is null.
      conversationFlowService.setNextCardIfStuck(null);
      let solutionSpy = spyOn(
        hintsAndSolutionManagerService,
        'releaseSolution'
      );
      let redirectionSpy = spyOn(conversationFlowService, 'showUpcomingCard');
      const solutionForState = Solution.createNew(
        true,
        'answer',
        'Html',
        'XyzID'
      );
      conversationFlowService.setSolutionForState(solutionForState);
      for (let index = 0; index < 3; index++) {
        playerTranscriptService.incrementNumberOfIncorrectSubmissions();
      }
      conversationFlowService.triggerIfLearnerStuckAction(false, () => {
        componentInstance.continueToReviseStateButtonIsVisible = true;
      });

      expect(solutionSpy).toHaveBeenCalled();
      expect(redirectionSpy).not.toHaveBeenCalled();
    })
  );

  it(
    'should immediately direct the learner to the stuck' +
      ' when the learner gets stuck and such a state exists',
    fakeAsync(() => {
      spyOn(translateService, 'instant').and.callThrough();
      spyOn(conversationFlowService, 'showPendingCard');
      spyOn(playerTranscriptService, 'addNewResponseToExistingFeedback');
      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(
        false
      );
      const nextCardIfStuck = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        '',
        null
      );
      conversationFlowService.setNextCardIfStuck(nextCardIfStuck);
      conversationFlowService.triggerIfLearnerStuckAction(false, () => {
        componentInstance.continueToReviseStateButtonIsVisible = true;
      });

      expect(translateService.instant).toHaveBeenCalledWith(
        'I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE'
      );
      expect(componentInstance.continueToReviseStateButtonIsVisible).toEqual(
        true
      );
    })
  );

  it('should redirect the learner to stuck state', fakeAsync(() => {
    spyOn(conversationFlowService, 'showPendingCard');
    const nextCardIfStuck = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      '',
      null
    );

    conversationFlowService.setNextCardIfStuck(nextCardIfStuck);
    componentInstance.triggerRedirectionToStuckState();

    const nextCard = conversationFlowService.getNextStateCard();
    expect(nextCard).toEqual(nextCardIfStuck);
    expect(conversationFlowService.showPendingCard).toHaveBeenCalled();
  }));

  it(
    'should navigate to the most recently reached checkpoint ' +
      'on page load if user is logged in',
    fakeAsync(() => {
      let stateCardNames = ['Start', 'Mid', 'End'];
      let stateCards: StateCard[] = [];
      for (let stateName in stateCardNames) {
        stateCards.push(
          new StateCard(
            stateName,
            '<p>Testing</p>',
            null,
            new Interaction([], [], null, null, [], 'Continue', null),
            [],
            'content',
            null
          )
        );
      }
      let alertMessageElement = document.createElement('div');
      alertMessageElement.className = 'oppia-exploration-checkpoints-message';
      const expResponse = explorationResponse;
      expResponse.exploration.states.Mid.card_is_checkpoint = true;

      spyOn(userService, 'getUserInfoAsync').and.returnValue(
        Promise.resolve(
          new UserInfo([], false, false, false, false, false, '', '', '', true)
        )
      );
      spyOn(playerPositionService, 'init').and.callFake(callb => {
        callb();
      });
      componentInstance.questionPlayerConfig = {};
      spyOn(conversationFlowService.onPlayerStateChange, 'emit');
      spyOn(playerPositionService.onLoadedMostRecentCheckpoint, 'emit');
      spyOn(focusManagerService, 'setFocusIfOnDesktop');
      spyOn(loaderService, 'hideLoadingScreen');
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
      spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
        explorationEngineService
      );
      spyOn(explorationEngineService, 'getLanguageCode').and.returnValues(
        'en',
        'en',
        'en',
        'pq'
      );
      spyOn(questionPlayerEngineService, 'initQuestionPlayer').and.callFake(
        (config, callb, questionAreAvailable) => {
          callb(displayedCard, 'label');
        }
      );
      spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
        false
      );
      spyOn(cardAnimationService, 'adjustPageHeight');
      spyOn(playerPositionService.onNewCardOpened, 'emit');
      spyOn(playerPositionService, 'setDisplayedCardIndex');
      spyOn(playerPositionService, 'getCurrentStateName').and.returnValues(
        'Start',
        'Mid',
        'End'
      );
      spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);
      spyOn(
        readOnlyExplorationBackendApiService,
        'loadLatestExplorationAsync'
      ).and.returnValue(Promise.resolve(expResponse));
      playerTranscriptService.setPrevSessionStatesProgress(['Start', 'Mid']);
      spyOn(explorationEngineService, 'getShortestPathToState').and.returnValue(
        ['Start', 'Mid']
      );
      spyOn(explorationEngineService, 'getStateCardByName').and.returnValues(
        stateCards[0],
        stateCards[1],
        stateCards[2]
      );

      spyOn(explorationEngineService, 'getStateFromStateName').and.callFake(
        stateName => {
          if (stateName === 'Mid') {
            return {
              cardIsCheckpoint: true,
              ...expResponse.exploration.states.Mid,
            };
          } else if (stateName === 'Start') {
            return {
              cardIsCheckpoint: true,
              ...expResponse.exploration.states.Start,
            };
          } else if (stateName === 'End') {
            return {
              cardIsCheckpoint: false,
              ...expResponse.exploration.states.End,
            };
          }
        }
      );

      spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
      spyOn(explorationEngineService, 'getState').and.returnValue(
        stateObjectFactory.createFromBackendDict(
          'Mid',
          expResponse.exploration.states.Mid
        )
      );
      spyOn(document, 'querySelector')
        .withArgs('.oppia-exploration-checkpoints-message')
        .and.returnValue(alertMessageElement);

      componentInstance.explorationId = expResponse.exploration_id;
      conversationFlowService.setDisplayedCard(displayedCard);
      componentInstance.isLoggedIn = true;
      componentInstance.isIframed = false;
      checkpointProgressService.setMostRecentlyReachedCheckpoint('Mid');

      componentInstance.initializePage();
      tick(6000);
      flush();

      const mostRecentlyReachedCheckpoint =
        checkpointProgressService.getMostRecentlyReachedCheckpoint();
      const prevSessionStatesProgress =
        playerTranscriptService.getPrevSessionStatesProgress();
      const visitedCheckpointStateNames =
        checkpointProgressService.visitedCheckpointStateNames;
      expect(visitedCheckpointStateNames).toContain('Mid');
      expect(prevSessionStatesProgress).toEqual(['Start']);
      expect(mostRecentlyReachedCheckpoint).toBe('Mid');

      playerTranscriptService.setPrevSessionStatesProgress([]);
      checkpointProgressService.resetVisitedCheckpointStateNames();
      componentInstance.initializePage();
      tick(100);
      flush();
    })
  );

  it('should return the exploration link', () => {
    const mockSummary = new LearnerExplorationSummary(
      'Math',
      false,
      'exp123',
      'en',
      100,
      'Learn addition',
      'public',
      ['addition'],
      '#F8BF74',
      '/subjects/Math.svg',
      'Addition Basics',
      'exploration',
      Date.now(),
      Date.now() - 100000,
      {5: 10, 4: 2, 3: 0, 2: 0, 1: 0},
      {alice: {num_commits: 3}}
    );

    conversationFlowService.setRecommendedExplorationSummaries([mockSummary]);

    spyOn(
      explorationRecommendationsService,
      'getExplorationLink'
    ).and.returnValue('/explore/exp123');

    const result = componentInstance.getExplorationLink();

    expect(result).toBe('/explore/exp123');
    expect(
      explorationRecommendationsService.getExplorationLink
    ).toHaveBeenCalledWith([mockSummary]);
  });

  it(
    'should display the exploration after the the progress reminder modal' +
      'has loaded',
    () => {
      spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
        false
      );
      spyOn(pageContextService, 'isInExplorationPlayerPage').and.returnValue(
        true
      );
      spyOn(urlService, 'getCollectionIdFromExplorationUrl').and.returnValue(
        null
      );
      spyOn(urlService, 'getPidFromUrl').and.returnValue(null);
      spyOn(pageContextService, 'getExplorationId').and.returnValue('expl_1');
      spyOn(urlService, 'isIframed').and.returnValue(false);

      componentInstance.ngOnInit();
      expect(conversationFlowService.hasFullyLoaded).toBe(false);
      conversationFlowService.onShowProgressModal.emit();
      expect(conversationFlowService.hasFullyLoaded).toBe(true);
    }
  );

  it('should determine if chapter was completed for the first time', fakeAsync(() => {
    componentInstance.isLoggedIn = true;
    conversationFlowService.setIsLoggedIn(true);
    spyOn(pageContextService, 'getExplorationId').and.returnValue('expId');
    spyOn(pageContextService, 'isInQuestionPlayerMode').and.returnValue(false);
    chapterProgressService.setCompletedChaptersCount(0);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(contentTranslationManagerService, 'displayTranslations');
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(componentInstance, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue(['123']);
    const storyModeSpy = spyOn(
      explorationModeService,
      'isInStoryChapterMode'
    ).and.returnValue(true);
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId',
    });
    spyOn(urlInterpolationService, 'interpolateUrl').and.returnValue('story');
    let readOnlyStoryNode = new ReadOnlyStoryNode(
      'nodeId',
      '',
      '',
      [],
      [],
      [],
      '',
      false,
      '',
      null,
      false,
      '',
      ''
    );
    spyOn(storyViewerBackendApiService, 'fetchStoryDataAsync').and.returnValue(
      Promise.resolve(
        new StoryPlaythrough(
          'nodeId',
          [readOnlyStoryNode, readOnlyStoryNode],
          '',
          '',
          '',
          ''
        )
      )
    );
    spyOn(
      learnerDashboardBackendApiService,
      'fetchLearnerCompletedChaptersCountDataAsync'
    ).and.returnValue(
      Promise.resolve({
        completedChaptersCount: 1,
      })
    );
    chapterProgressService.updateCompletedChaptersCount(true);
    spyOn(
      storyViewerBackendApiService,
      'recordChapterCompletionAsync'
    ).and.returnValue(
      Promise.resolve({
        readyForReviewTest: true,
        nextNodeId: '',
        summaries: [],
      })
    );
    spyOn(playerPositionService, 'recordAnswerSubmission');
    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
      explorationEngineService
    );
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(windowDimensionsService, 'getWidth').and.returnValue('1777');

    conversationFlowService.setDisplayedCard(
      new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        '',
        null
      )
    );
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValues(false, true, true, false);
    spyOn(cardAnimationService, 'animateToOneCard');

    conversationFlowService.showPendingCard();
    tick(1000);

    let completedChaptersCount =
      chapterProgressService.getCompletedChaptersCount();
    let chapterIsCompletedForTheFirstTime =
      chapterProgressService.getChapterCompletedForTheFirstTime();
    expect(chapterIsCompletedForTheFirstTime).toBe(true);
    expect(completedChaptersCount).toBe(1);

    storyModeSpy.and.returnValue(false);
    chapterProgressService.setCompletedChaptersCount(1);
    chapterProgressService.setChapterCompletedForTheFirstTime(false);

    conversationFlowService.showPendingCard();
    tick(1000);

    chapterIsCompletedForTheFirstTime =
      chapterProgressService.getChapterCompletedForTheFirstTime();
    expect(chapterIsCompletedForTheFirstTime).toBe(false);

    flush();
  }));

  it('should unsubscribe on destroy', () => {
    spyOn(componentInstance.directiveSubscriptions, 'unsubscribe');

    componentInstance.ngOnDestroy();

    expect(
      componentInstance.directiveSubscriptions.unsubscribe
    ).toHaveBeenCalled();
  });

  it('should get can ask learner for answer info', () => {
    spyOn(
      learnerAnswerInfoService,
      'getCanAskLearnerForAnswerInfo'
    ).and.returnValues(true, false);

    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeTrue();
    expect(componentInstance.getCanAskLearnerForAnswerInfo()).toBeFalse();
  });

  it('should get displayedCard', () => {
    spyOn(conversationFlowService, 'getDisplayedCard').and.returnValue(
      displayedCard
    );

    expect(componentInstance.getDisplayedCard()).toEqual(displayedCard);
  });

  it('should tell if correctness footer is enabled', () => {
    conversationFlowService.setAnswerIsCorrect(true);

    spyOn(
      playerPositionService,
      'hasLearnerJustSubmittedAnAnswer'
    ).and.returnValue(true);

    expect(componentInstance.isCorrectnessFooterEnabled()).toBeTrue();
  });

  it('should get static image url', () => {
    let imageUrl = 'image_url';
    spyOn(urlInterpolationService, 'getStaticImageUrl').and.returnValue(
      imageUrl
    );

    expect(componentInstance.getStaticImageUrl('')).toEqual(imageUrl);
  });

  it('should tell if display card is terminal', () => {
    conversationFlowService.setDisplayedCard(
      new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        '',
        null
      )
    );

    expect(componentInstance.isOnTerminalCard()).toBeTrue();
  });

  it('should return to exploration after concept card is compeleted', () => {
    let numCards = 20;
    spyOn(playerTranscriptService, 'addPreviousCard');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(numCards);
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    conceptCardManagerService.returnToExplorationAfterConceptCard();

    expect(playerTranscriptService.addPreviousCard).toHaveBeenCalled();
    expect(playerTranscriptService.getNumCards).toHaveBeenCalled();
    expect(
      playerPositionService.setDisplayedCardIndex
    ).toHaveBeenCalledOnceWith(numCards - 1);
  });

  it('should tell if current is at end of transcript', () => {
    let index = 1;
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(
      index
    );

    expect(componentInstance.isCurrentCardAtEndOfTranscript()).toBeTrue();
    expect(playerTranscriptService.isLastCard).toHaveBeenCalledWith(index);
  });

  it('should hide loading screen if question are not available', () => {
    spyOn(loaderService, 'hideLoadingScreen');

    componentInstance.showQuestionAreNotAvailable();

    expect(loaderService.hideLoadingScreen).toHaveBeenCalled();
  });

  it('should initialize page', fakeAsync(() => {
    spyOn(conversationFlowService, 'navigateToDisplayedCard').and.callFake(
      () => {}
    );
    spyOn(
      conversationFlowService,
      'initializeDirectiveComponents'
    ).and.callFake(() => {});
    spyOn(playerPositionService, 'init').and.callFake(callb => {
      callb();
    });
    spyOn(urlService, 'getUrlParams').and.returnValues(
      {
        lang: 'pq',
      },
      {
        lang: 'en',
      },
      {
        lang: 'en',
      },
      {
        lang: 'pq',
      }
    );
    spyOn(userService, 'getUserInfoAsync').and.returnValue(
      Promise.resolve(
        new UserInfo([], false, false, false, false, false, '', '', '', true)
      )
    );
    componentInstance.questionPlayerConfig = {};
    spyOn(conversationFlowService.onPlayerStateChange, 'emit');
    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(loaderService, 'hideLoadingScreen');
    spyOn(questionPlayerEngineService, 'initQuestionPlayer').and.callFake(
      (config, callb, questionAreAvailable) => {
        callb(displayedCard, 'label');
      }
    );
    spyOn(cardAnimationService, 'adjustPageHeight');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    componentInstance.isIframed = true;
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);

    componentInstance.explorationId = explorationResponse.exploration_id;
    conversationFlowService.setDisplayedCard(displayedCard);

    componentInstance.initializePage();
    tick(100);
    expect(playerPositionService.init).toHaveBeenCalled();

    componentInstance.questionPlayerConfig = null;
    spyOn(playerPositionService, 'getDisplayedCardIndex');
    spyOn(playerTranscriptService, 'getCard').and.returnValue(displayedCard);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(true, false);
    spyOn(explorationInitializationService, 'initializePlayer').and.callFake(
      callb => {
        callb(displayedCard, 'label');
      }
    );
    spyOn(urlService, 'isIframed').and.returnValue(false);

    componentInstance.initializePage();
    tick(100);

    componentInstance.questionPlayerConfig = null;
    let topicIdToPrerequisiteTopicIds = {
      topicId1: [],
      topicId2: ['topicId1'],
      topicId3: ['topicId2'],
    };

    componentInstance.diagnosticTestTopicTrackerModel =
      new DiagnosticTestTopicTrackerModel(topicIdToPrerequisiteTopicIds);

    spyOn(diagnosticTestPlayerEngineService, 'init');

    componentInstance.initializePage();
    tick(100);

    expect(playerPositionService.init).toHaveBeenCalled();
    expect(diagnosticTestPlayerEngineService.init).toHaveBeenCalled();
  }));

  it('should submit answer from progress nav and toggle submit clicked', () => {
    conversationFlowService.setDisplayedCard(displayedCard);
    spyOn(displayedCard, 'toggleSubmitClicked');
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(currentInteractionService, 'submitAnswer');

    componentInstance.submitAnswerFromProgressNav();

    expect(currentInteractionService.submitAnswer).toHaveBeenCalled();
    expect(displayedCard.toggleSubmitClicked).toHaveBeenCalledOnceWith(true);
  });

  it('should tell if current supplemental card is non empty', () => {
    conversationFlowService.setDisplayedCard(displayedCard);
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValues(true, false);

    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeTrue();
    expect(componentInstance.isCurrentSupplementalCardNonempty()).toBeFalse();
  });

  it('should tell if supplemental nav is shown', () => {
    conversationFlowService.setDisplayedCard(
      new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'NumberWithUnits', null),
        [],
        '',
        null
      )
    );
    spyOn(explorationModeService, 'isInQuestionMode').and.returnValues(
      false,
      true
    );
    spyOn(componentInstance, 'isCurrentCardAtEndOfTranscript').and.returnValue(
      true
    );
    expect(componentInstance.isSupplementalNavShown()).toBeFalse();
    expect(componentInstance.isSupplementalNavShown()).toBeTrue();
  });

  it('should return false when interaction id is not in INTERACTION_SPECS', () => {
    const unknownInteraction = new Interaction(
      [],
      [],
      null,
      null,
      [],
      'UnknownId',
      null
    );
    conversationFlowService.setDisplayedCard(
      new StateCard(null, null, null, unknownInteraction, [], '', null)
    );
    spyOn(explorationModeService, 'isInQuestionMode').and.returnValue(true);
    expect(componentInstance.isSupplementalNavShown()).toBeFalse();
  });

  it('should return false when interaction.id is null', () => {
    const interactionWithNullId = new Interaction(
      [],
      [],
      null,
      null,
      [],
      null,
      null
    );
    const card = new StateCard(
      'StateName',
      null,
      null,
      interactionWithNullId,
      [],
      '',
      null
    );
    conversationFlowService.setDisplayedCard(card);

    spyOn(explorationModeService, 'isInQuestionMode').and.returnValue(true);

    expect(componentInstance.isSupplementalNavShown()).toBeFalse();
  });

  it('should call changeDetectorRef.detectChanges if submitButtonIsDisabled changes in ngAfterViewChecked', () => {
    spyOn(componentInstance, 'isSubmitButtonDisabled').and.returnValues(
      false,
      true
    );
    componentInstance.submitButtonIsDisabled = false;
    // eslint-disable-next-line dot-notation
    spyOn(componentInstance['changeDetectorRef'], 'detectChanges');
    // First call: no change.
    componentInstance.ngAfterViewChecked();
    expect(
      // eslint-disable-next-line dot-notation
      componentInstance['changeDetectorRef'].detectChanges
    ).not.toHaveBeenCalled();
    // Second call: value changes.
    componentInstance.submitButtonIsDisabled = false;
    componentInstance.ngAfterViewChecked();
    expect(
      // eslint-disable-next-line dot-notation
      componentInstance['changeDetectorRef'].detectChanges
    ).toHaveBeenCalled();
  });

  it('should get answer is being processed', () => {
    spyOn(conversationFlowService, 'getAnswerIsBeingProcessed').and.returnValue(
      true
    );
    expect(componentInstance.getAnswerIsBeingProcessed()).toBeTrue();
  });

  it('should get is in story mode', () => {
    spyOn(explorationModeService, 'isInStoryChapterMode').and.returnValue(true);
    expect(componentInstance.getIsInStoryMode()).toBeTrue();
  });

  it('should get exploration link', () => {
    const link = 'exploration_link';
    spyOn(
      conversationFlowService,
      'getRecommendedExplorationSummaries'
    ).and.returnValue([]);
    spyOn(
      explorationRecommendationsService,
      'getExplorationLink'
    ).and.returnValue(link);
    expect(componentInstance.getExplorationLink()).toBe(link);
  });

  it('should get recommendation exploration summaries', () => {
    const summaries = [{id: 1}];
    spyOn(
      conversationFlowService,
      'getRecommendedExplorationSummaries'
    ).and.returnValue(summaries);
    expect(componentInstance.getRecommendationExplorationSummaries()).toBe(
      summaries
    );
  });

  it('should get has fully loaded', () => {
    spyOn(conversationFlowService, 'getHasFullyLoaded').and.returnValue(true);
    expect(componentInstance.getHasFullyLoaded()).toBeTrue();
  });

  it('should return true if window can show two cards', () => {
    const widthSpy = spyOn(windowDimensionsService, 'getWidth').and.returnValue(
      2000
    );
    expect(componentInstance.canWindowShowTwoCards()).toBeTrue();

    widthSpy.and.returnValue(500);
    expect(componentInstance.canWindowShowTwoCards()).toBeFalse();
  });

  it('should show progress clearance message if service returns true', () => {
    spyOn(
      conversationFlowService,
      'getShowProgressClearanceMessage'
    ).and.returnValue(true);
    expect(componentInstance.isProgressClearanceMessageShown()).toBeTrue();
  });

  it('should check if displayed card was completed in previous session', () => {
    const prevStates = ['State1', 'State2'];
    const displayedCardMock = {
      getInteraction: () => true,
      getStateName: () => 'State2',
    };
    spyOn(
      playerTranscriptService,
      'getPrevSessionStatesProgress'
    ).and.returnValue(prevStates);
    spyOn(conversationFlowService, 'getDisplayedCard').and.returnValue(
      displayedCardMock
    );
    expect(
      componentInstance.isDisplayedCardCompletedInPrevSession()
    ).toBeTrue();
  });

  it('should get recommended exp title translation key', () => {
    spyOn(
      i18nLanguageCodeService,
      'getExplorationTranslationKey'
    ).and.returnValue('key');
    expect(
      componentInstance.getRecommendedExpTitleTranslationKey('expId')
    ).toBe('key');
  });

  it('should check if hacky exp title translation is displayed', () => {
    spyOn(
      componentInstance,
      'getRecommendedExpTitleTranslationKey'
    ).and.returnValue('key');
    spyOn(
      i18nLanguageCodeService,
      'isHackyTranslationAvailable'
    ).and.returnValue(true);

    const currentLangSpy = spyOn(
      i18nLanguageCodeService,
      'isCurrentLanguageEnglish'
    ).and.returnValue(false);
    expect(
      componentInstance.isHackyExpTitleTranslationDisplayed('expId')
    ).toBeTrue();

    currentLangSpy.and.returnValue(true);
    expect(
      componentInstance.isHackyExpTitleTranslationDisplayed('expId')
    ).toBeFalse();
  });

  it('should call skipCurrentQuestion and update next card', () => {
    const nextCard = {};
    spyOn(
      diagnosticTestPlayerEngineService,
      'skipCurrentQuestion'
    ).and.callFake(cb => cb(nextCard));
    spyOn(conversationFlowService, 'setNextStateCard');
    spyOn(conversationFlowService, 'showPendingCard');
    componentInstance.skipCurrentQuestion();
    expect(conversationFlowService.setNextStateCard).toHaveBeenCalledWith(
      nextCard
    );
    expect(conversationFlowService.showPendingCard).toHaveBeenCalled();
  });

  it('should trigger redirection to stuck state', () => {
    const nextCard = {};
    spyOn(conversationFlowService, 'getNextCardIfStuck').and.returnValue(
      nextCard
    );
    spyOn(conversationFlowService, 'setNextStateCard');
    spyOn(conversationFlowService, 'showPendingCard');
    componentInstance.showInteraction = true;
    componentInstance.triggerRedirectionToStuckState();
    expect(conversationFlowService.setNextStateCard).toHaveBeenCalledWith(
      nextCard
    );
    expect(componentInstance.showInteraction).toBeFalse();
    expect(conversationFlowService.showPendingCard).toHaveBeenCalled();
  });

  it('should return value from conversationFlowService in isLearnAgainButton', () => {
    const spy = spyOn(
      conversationFlowService,
      'isLearnAgainButton'
    ).and.returnValue(true);
    expect(componentInstance.isLearnAgainButton()).toBeTrue();

    spy.and.returnValue(false);
    expect(componentInstance.isLearnAgainButton()).toBeFalse();
  });

  it('should get recommended summaries when exploration in story chapter mode', fakeAsync(() => {
    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
      explorationEngineService
    );
    spyOn(explorationEngineService, 'recordNewCardAdded');
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');

    let alertMessageElement = document.createElement('div');
    alertMessageElement.className = 'oppia-exploration-checkpoints-message';

    spyOn(focusManagerService, 'setFocusIfOnDesktop');
    spyOn(playerPositionService.onNewCardOpened, 'emit');
    spyOn(cardAnimationService, 'scheduleNextCardTransition');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(0);
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValue(false);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);
    spyOn(
      explorationEngineService,
      'getAuthorRecommendedExpIdsByStateName'
    ).and.returnValue([]);
    spyOn(explorationModeService, 'isInStoryChapterMode').and.returnValue(
      false
    );

    spyOn(
      explorationRecommendationsService,
      'getRecommendedSummaryDicts'
    ).and.callFake((ids, recommendations, callb) => {
      const mockSummaries = [{id: 'exp1'}, {id: 'exp2'}];
      callb(mockSummaries);
    });

    spyOn(document, 'querySelector')
      .withArgs('.oppia-exploration-checkpoints-message')
      .and.returnValue(alertMessageElement);

    conversationFlowService.displayedCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      '',
      null
    );

    conversationFlowService.showPendingCard();

    tick(2000);
    flush();
  }));
});
