// Copyright 2024 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Service to manage the conversation flow of the exploration player,
 * controlling behaviours such as adding cards to the stack, or submitting the
 * answer to progress further.
 */

import {StateCard} from 'domain/state_card/state-card.model';
import {EventEmitter, Injectable} from '@angular/core';
import {ContentTranslationLanguageService} from './content-translation-language.service';
import {ContentTranslationManagerService} from './content-translation-manager.service';
import {PlayerTranscriptService} from './player-transcript.service';
import {CurrentEngineService} from './current-engine.service';
import {Solution} from 'domain/exploration/solution.model';
import {ExplorationPlayerConstants} from '../current-lesson-player/exploration-player-page.constants';
import {TranslateService} from '@ngx-translate/core';
import {HintsAndSolutionManagerService} from './hints-and-solution-manager.service';
import {PlayerPositionService} from './player-position.service';
import {StatsReportingService} from './stats-reporting.service';
import {PageContextService} from 'services/page-context.service';
import {ConceptCardManagerService} from './concept-card-manager.service';
import {StateEditorService} from 'components/state-editor/state-editor-properties-services/state-editor.service';
import {ConceptCardBackendApiService} from 'domain/skill/concept-card-backend-api.service';
import {ExplorationSummaryBackendApiService} from 'domain/summary/exploration-summary-backend-api.service';
import {RefresherExplorationConfirmationModalService} from './refresher-exploration-confirmation-modal.service';
import {ExplorationEngineService} from './exploration-engine.service';
import {VoiceoverPlayerService} from './voiceover-player.service';
import {AppConstants} from 'app.constants';
import {AudioPlayerService} from 'services/audio-player.service';
import {ExplorationModeService} from './exploration-mode.service';
import {LearnerAnswerInfoService} from './learner-answer-info.service';
import INTERACTION_SPECS from 'interactions/interaction_specs.json';
import {NumberAttemptsService} from './number-attempts.service';
import {InteractionRulesService} from './answer-classification.service';
import {FatigueDetectionService} from './fatigue-detection.service';
import {QuestionPlayerEngineService} from './question-player-engine.service';
import {ChapterProgressService} from './chapter-progress.service';
import {LearnerParamsService} from './learner-params.service';
import {CurrentInteractionService} from './current-interaction.service';
import {FocusManagerService} from 'services/stateful/focus-manager.service';
import {CardAnimationService} from './card-animation.service';
import {UrlService} from 'services/contextual/url.service';
import {LearnerExplorationSummary} from 'domain/summary/learner-exploration-summary.model';
import {UserService} from 'services/user.service';
import {ExplorationRecommendationsService} from './exploration-recommendations.service';
import {StoryViewerDomainConstants} from 'domain/story_viewer/story-viewer-domain.constants';
import {TopicViewerDomainConstants} from 'domain/topic_viewer/topic-viewer-domain.constants';
import {UrlInterpolationService} from 'domain/utilities/url-interpolation.service';
import {WindowRef} from 'services/contextual/window-ref.service';
import {StoryViewerBackendApiService} from 'domain/story_viewer/story-viewer-backend-api.service';
import {StateObjectsBackendDict} from 'domain/exploration/StatesObjectFactory';
import {ReadOnlyExplorationBackendApiService} from 'domain/exploration/read-only-exploration-backend-api.service';
import {CheckpointProgressService} from './checkpoint-progress.service';
import {I18nLanguageCodeService} from 'services/i18n-language-code.service';
import {LoaderService} from 'services/loader.service';
import {ProgressUrlService} from './progress-url.service';
import {EditableExplorationBackendApiService} from 'domain/exploration/editable-exploration-backend-api.service';
import {AutogeneratedAudioPlayerService} from 'services/autogenerated-audio-player.service';
import {DiagnosticTestPlayerEngineService} from './diagnostic-test-player-engine.service';
import {Interaction} from 'domain/exploration/interaction.model';

interface AnswerResponseData {
  displayedCard: StateCard;
  editorPreviewMode: boolean;
  nextCard: StateCard;
  refreshInteraction: boolean;
  feedbackHtml: string;
  refresherExplorationId: string | null;
  missingPrerequisiteSkillId: string | null;
  remainOnCurrentCard: boolean;
  taggedSkillMisconceptionId: string;
  wasOldStateInitial: boolean;
  isFirstHit: boolean;
  isFinalQuestion: boolean;
  nextCardIfReallyStuck: StateCard | null;
  focusLabel: string;
  timeAtServerCall: number;
  currentEngineService:
    | ExplorationEngineService
    | QuestionPlayerEngineService
    | DiagnosticTestPlayerEngineService;
}

@Injectable({
  providedIn: 'root',
})
export class ConversationFlowService {
  nextCardIfStuck!: StateCard | null;
  solutionForState: Solution | null = null;
  responseTimeout: NodeJS.Timeout | null = null;
  nextStateCard!: StateCard;
  displayedCard!: StateCard;

  // The following variables are used to track the state of the answer submission process.
  answerIsCorrect = false;
  answerIsBeingProcessed: boolean = false;
  hasInteractedAtLeastOnce: boolean = false;
  explorationActuallyStarted: boolean = false;

  pendingCardWasSeenBefore: boolean = false;
  questionSessionCompleted: boolean = false;
  moveToExploration: boolean = false;
  showProgressClearanceMessage: boolean = false;
  recommendedExplorationSummaries: LearnerExplorationSummary[] = [];
  isLoggedIn!: boolean;
  hasFullyLoaded: boolean = false;
  _nextFocusLabel!: string;

  // TODO(#22780): Remove these variable and related code.
  redirectToRefresherExplorationConfirmed!: boolean;
  isRefresherExploration!: boolean;
  parentExplorationIds: string[] = [];

  private _playerStateChangeEventEmitter: EventEmitter<string> =
    new EventEmitter<string>();

  private _oppiaFeedbackAvailableEventEmitter: EventEmitter<void> =
    new EventEmitter();

  private _playerProgressModalShownEventEmitter: EventEmitter<boolean> =
    new EventEmitter<boolean>();

  constructor(
    private contentTranslationLanguageService: ContentTranslationLanguageService,
    private contentTranslationManagerService: ContentTranslationManagerService,
    private playerTranscriptService: PlayerTranscriptService,
    private editableExplorationBackendApiService: EditableExplorationBackendApiService,
    private playerPositionService: PlayerPositionService,
    private windowRef: WindowRef,
    private progressUrlService: ProgressUrlService,
    private readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService,
    private storyViewerBackendApiService: StoryViewerBackendApiService,
    private checkpointProgressService: CheckpointProgressService,
    private urlInterpolationService: UrlInterpolationService,
    private learnerAnswerInfoService: LearnerAnswerInfoService,
    private stateEditorService: StateEditorService,
    private fatigueDetectionService: FatigueDetectionService,
    private refresherExplorationConfirmationModalService: RefresherExplorationConfirmationModalService,
    private pageContextService: PageContextService,
    private voiceoverPlayerService: VoiceoverPlayerService,
    private currentInteractionService: CurrentInteractionService,
    private explorationModeService: ExplorationModeService,
    private audioPlayerService: AudioPlayerService,
    private cardAnimationService: CardAnimationService,
    private autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService,
    private loaderService: LoaderService,
    private learnerParamsService: LearnerParamsService,
    private urlService: UrlService,
    private focusManagerService: FocusManagerService,
    private chapterProgressService: ChapterProgressService,
    private i18nLanguageCodeService: I18nLanguageCodeService,
    private userService: UserService,
    private explorationRecommendationsService: ExplorationRecommendationsService,
    private explorationSummaryBackendApiService: ExplorationSummaryBackendApiService,
    private conceptCardBackendApiService: ConceptCardBackendApiService,
    private conceptCardManagerService: ConceptCardManagerService,
    private currentEngineService: CurrentEngineService,
    private statsReportingService: StatsReportingService,
    private explorationEngineService: ExplorationEngineService,
    private questionPlayerEngineService: QuestionPlayerEngineService,
    private numberAttemptsService: NumberAttemptsService,
    private translateService: TranslateService,
    private hintsAndSolutionManagerService: HintsAndSolutionManagerService
  ) {}

  /**
   * Determines whether the supplemental card (i.e., the card displayed
   * in the right pane) should be shown.
   *
   * A card is considered supplemental (non-empty) if its interaction is
   * not inline (i.e., it should appear alongside the main content).
   *
   * @param {StateCard} card - The state card to evaluate.
   * @returns {boolean} - True if the card has a supplemental (non-inline) view; otherwise, false.
   */
  isSupplementalCardNonempty(card: StateCard): boolean {
    return !card.isInteractionInline();
  }

  /**
   * Triggers the stuck learner logic, based on either a delayed timer
   * (e.g., 150 seconds of inactivity) or immediately if not delayed.
   *
   * This method is responsible for determining whether the "Continue"
   * button should be shown to help the learner move forward if they are stuck.
   *
   * --- Trigger Conditions ---
   * • When a new card is opened:
   *    – Starts a 150-second timer.
   *    – If hints are available but not fully consumed, and the learner
   *      hasn't answered the question, the "Continue" button is shown
   *      after the timeout.
   *
   * • After all hints are consumed:
   *    – Timer is reset and restarted for 150 seconds.
   *    – If the question remains unanswered after timeout, the
   *      "Continue" button is shown.
   *
   * @param {boolean} isDelayed - Whether to wait before performing
   *   the stuck check (typically true for inactivity-based triggers).
   * @param {() => void} onShowContinueToReviseButton - Callback to display
   *   the "Continue" button when the learner is deemed stuck.
   */
  triggerIfLearnerStuckAction(
    isDelayed: boolean,
    onShowContinueToReviseButton: () => void
  ): void {
    if (this.responseTimeout) {
      clearTimeout(this.responseTimeout);
      this.responseTimeout = null;
    }

    if (isDelayed) {
      this.responseTimeout = setTimeout(() => {
        this._performStuckCheck(onShowContinueToReviseButton);
      }, ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC);
    } else {
      this._performStuckCheck(onShowContinueToReviseButton);
    }
  }

  /**
   * Moves the displayed card forward by one position in the previously seen cards.
   *
   * This method should only be used when navigating through cards the user
   * has already seen, not for progressing to new or unseen cards.
   *
   * Retrieves the current displayed card index from the player position service,
   * increments it by one, and updates the displayed card accordingly.
   */
  moveForwardByOneCard(): void {
    let displayedCardIndex = this.playerPositionService.getDisplayedCardIndex();
    this._validateIndexAndChangeCard(displayedCardIndex + 1);
  }

  /**
   * Moves the displayed card backward by one position in the previously seen cards.
   *
   * This method should only be used when navigating through cards the user
   * has already seen, not for progressing to new or unseen cards.
   *
   * Retrieves the current displayed card index from the player position service,
   * decrements it by one, and updates the displayed card accordingly.
   */
  moveBackByOneCard(): void {
    let displayedCardIndex = this.playerPositionService.getDisplayedCardIndex();
    this._validateIndexAndChangeCard(displayedCardIndex - 1);
  }

  /**
   * Navigates to the currently displayed card and performs necessary
   * state updates such as checkpoint tracking, focus management, and
   * audio playback.
   *
   * This method:
   * - Records the most recently reached checkpoint if the current card
   *   is a checkpoint and hasn't been visited yet.
   * - Emits events to update card position and trigger audio playback.
   * - Sets the focus to the appropriate content element based on
   *   whether it's the last card or not.
   */
  navigateToDisplayedCard(): void {
    let isIframed = this.urlService.isIframed();
    let index = this.playerPositionService.getDisplayedCardIndex();
    let isInEditorPreviewMode =
      this.pageContextService.isInExplorationEditorPage();
    let explorationId = this.pageContextService.getExplorationId();
    this.displayedCard = this._getCurrentCard();

    if (
      index > 0 &&
      !isIframed &&
      !isInEditorPreviewMode &&
      !this.explorationModeService.isInQuestionPlayerMode() &&
      !this.explorationModeService.isInDiagnosticTestPlayerMode()
    ) {
      let currentState = this.explorationEngineService.getState();
      let currentStateName = currentState.name as string;
      if (currentStateName === null) {
        throw new Error(
          'Current state name cannot be null when navigating to displayed card.'
        );
      }
      let prevSessionStatesProgress =
        this.playerTranscriptService.getPrevSessionStatesProgress();
      if (
        currentState.cardIsCheckpoint &&
        !this.checkpointProgressService.checkIfCheckpointIsVisited(
          currentStateName
        ) &&
        !prevSessionStatesProgress.includes(currentStateName)
      ) {
        this.readOnlyExplorationBackendApiService
          .loadLatestExplorationAsync(explorationId)
          .then(response => {
            this.checkpointProgressService.setMostRecentlyReachedCheckpoint(
              currentStateName
            );
            let version = response.version;
            if (!version) {
              throw new Error(
                'Version cannot be null when recording checkpoint progress.'
              );
            }
            this.editableExplorationBackendApiService.recordMostRecentlyReachedCheckpointAsync(
              explorationId,
              version,
              currentStateName,
              this.isLoggedIn,
              this.progressUrlService.getUniqueProgressUrlId()
            );
          });
        this.checkpointProgressService.setVisitedCheckpointStateNames(
          currentStateName
        );
      }
    }

    this.playerPositionService.onActiveCardChanged.emit();

    this.audioPlayerService.onAutoplayAudio.emit();
    this.autogeneratedAudioPlayerService.cancel();
    let focusLabel = this.getNextFocusLabel();
    if (focusLabel && this.playerTranscriptService.isLastCard(index)) {
      this.focusManagerService.setFocusIfOnDesktop(focusLabel);
    } else {
      this.focusManagerService.setFocusIfOnDesktop(
        this._getContentFocusLabel(index)
      );
    }
  }

  /**
   * Submits the learner's answer to the current card.
   *
   * This method handles:
   * - Preventing duplicate or too-rapid submissions.
   * - Initializing learner answer info collection (if enabled).
   * - Passing the answer to the current engine service.
   * - Handling feedback or continuation based on the response.
   *
   * @param {string} answer - The answer provided by the learner.
   * @param {InteractionRulesService} interactionRulesService - The rules service used to evaluate the answer.
   */
  submitAnswer(
    answer: string,
    interactionRulesService: InteractionRulesService
  ): void {
    let editorPreviewMode = this.pageContextService.isInExplorationEditorPage();
    let explorationId = this.pageContextService.getExplorationId();
    this.displayedCard.updateCurrentAnswer(null);

    // Safety check to prevent double submissions from occurring.
    if (this._shouldBlockSubmission(this.displayedCard)) {
      return;
    }

    if (!editorPreviewMode && this._isSubmittingTooFast()) {
      return;
    }

    this._shouldInitLearnerAnswerInfo(
      editorPreviewMode,
      explorationId,
      answer,
      interactionRulesService
    );

    this._updateAnswerSubmissionState(answer);

    let canAskLearnerForAnswerInfo =
      this.learnerAnswerInfoService.getCanAskLearnerForAnswerInfo();
    if (canAskLearnerForAnswerInfo) {
      setTimeout(() => {
        this.playerTranscriptService.addNewResponse(
          this.learnerAnswerInfoService.getSolicitAnswerDetailsQuestion()
        );
        this.answerIsBeingProcessed = false;
        this._emitHelpCard(
          this.learnerAnswerInfoService.getSolicitAnswerDetailsQuestion(),
          false
        );
      }, 100);
      return;
    }

    let timeAtServerCall = new Date().getTime();
    this.playerPositionService.recordAnswerSubmission();
    const currentEngineService =
      this.currentEngineService.getCurrentEngineService();
    let displayedCard = this.displayedCard;
    this.answerIsCorrect = currentEngineService.submitAnswer(
      answer,
      interactionRulesService,
      (
        nextCard: StateCard,
        refreshInteraction: boolean,
        feedbackHtml: string,
        refresherExplorationId: string | null,
        missingPrerequisiteSkillId: string,
        remainOnCurrentCard: boolean,
        taggedSkillMisconceptionId: string,
        wasOldStateInitial: boolean,
        isFirstHit: boolean,
        isFinalQuestion: boolean,
        nextCardIfReallyStuck: StateCard | null,
        focusLabel: string
      ) => {
        this._handleAnswerResponse({
          displayedCard,
          editorPreviewMode,
          nextCard,
          refreshInteraction,
          feedbackHtml,
          refresherExplorationId,
          missingPrerequisiteSkillId,
          remainOnCurrentCard,
          taggedSkillMisconceptionId,
          wasOldStateInitial,
          isFirstHit,
          isFinalQuestion,
          nextCardIfReallyStuck,
          focusLabel,
          timeAtServerCall,
          currentEngineService,
        });
      }
    );
  }

  /**
   * Determines whether the "Learn Again" button should be shown instead of
   * "Continue" based on the learner's interaction history and correctness.
   *
   * The button is shown if:
   * - The same card is being revisited.
   * - The previous answer was incorrect.
   * - The card has a non-linear interaction.
   *
   * @returns {boolean} True if "Learn Again" button should be shown, false otherwise.
   */
  isLearnAgainButton(): boolean {
    let conceptCardIsBeingShown =
      this.displayedCard.getStateName() === null &&
      !this.explorationModeService.isInQuestionMode();
    if (conceptCardIsBeingShown) {
      return false;
    }
    let interaction = this.displayedCard.getInteraction();

    if (!interaction.id) {
      // An editor might also try to view preview tab without adding
      // interaction to concept card.
      return false;
    }

    if (
      INTERACTION_SPECS[interaction.id as keyof typeof INTERACTION_SPECS]
        .is_linear
    ) {
      return false;
    }

    return this.pendingCardWasSeenBefore && !this.getAnswerIsCorrect();
  }

  /**
   * Initializes the player view for an exploration or question session.
   * Sets up the initial card, triggers checkpoint navigation (if required),
   * manages language selection for iframed embeds, and scroll/focus handling.
   *
   * @param {StateCard} initialCard - The first state card to display in the exploration.
   * @param {string} focusLabel - The focus label for accessibility (used to set screen reader focus).
   */
  initializeDirectiveComponents(
    initialCard: StateCard,
    focusLabel: string
  ): void {
    let isIframed = this.urlService.isIframed();
    let isInEditorPreviewMode =
      this.pageContextService.isInExplorationEditorPage();

    this._addNewCard(initialCard);
    this.setNextStateCard(initialCard);
    if (!this.explorationModeService.isInDiagnosticTestPlayerMode()) {
      this.onPlayerStateChange.emit(initialCard.getStateName());
    }

    // We do not store checkpoints progress for iframes hence we do not
    // need to consider redirecting the user to the most recently
    // reached checkpoint on exploration initial load in that case.
    if (
      !isIframed &&
      !isInEditorPreviewMode &&
      !this.explorationModeService.isInQuestionPlayerMode() &&
      !this.explorationModeService.isInDiagnosticTestPlayerMode()
    ) {
      // Navigate the learner to the most recently reached checkpoint state.
      this._navigateToMostRecentlyReachedCheckpoint();
    }
    this.hasFullyLoaded = true;

    this.focusManagerService.setFocusIfOnDesktop(focusLabel);
    this.loaderService.hideLoadingScreen();

    // If the exploration is embedded, use the url language code
    // as site language. If the url language code is not supported
    // as site language, English is used as default.
    let langCodes = AppConstants.SUPPORTED_SITE_LANGUAGES.map(language => {
      return language.id;
    }) as string[];
    if (isIframed) {
      let urlLanguageCode = this.urlService.getUrlParams().lang;
      if (urlLanguageCode && langCodes.indexOf(urlLanguageCode) !== -1) {
        this.i18nLanguageCodeService.setI18nLanguageCode(urlLanguageCode);
      } else {
        this.i18nLanguageCodeService.setI18nLanguageCode('en');
      }
    }
    this.cardAnimationService.adjustPageHeight();
    this.windowRef.nativeWindow.scrollTo(0, 0);

    // The timeout is needed in order to give the recipient of the
    // broadcast sufficient time to load.
    setTimeout(() => {
      this.playerPositionService.onNewCardOpened.emit(initialCard);
    });
  }

  /**
   * Displays the next card to the learner.
   * Handles various cases like:
   * - Redirecting after concept cards.
   * - Showing result after question session ends.
   * - Looping back to exploration after session-based redirection.
   * - Showing concept card if needed.
   * - Revisiting previous cards if 'Learn Again' is triggered.
   * - Proceeding to the next pending card otherwise.
   */
  showUpcomingCard(): void {
    let currentIndex = this.playerPositionService.getDisplayedCardIndex();
    let conceptCardIsBeingShown =
      this.displayedCard.getStateName() === null &&
      !this.explorationModeService.isInQuestionMode();
    if (
      conceptCardIsBeingShown &&
      this.playerTranscriptService.isLastCard(currentIndex)
    ) {
      this.conceptCardManagerService.returnToExplorationAfterConceptCard();
      return;
    }
    if (this.questionSessionCompleted) {
      this.questionPlayerEngineService.onQuestionSessionCompleted.emit(
        this.questionPlayerEngineService.getQuestionPlayerStateData()
      );
      return;
    }
    if (this.moveToExploration) {
      this.moveToExploration = false;
      this.explorationModeService.setExplorationModeFromUrl();
      this.explorationEngineService.loadInitialState(
        this.initializeDirectiveComponents.bind(this)
      );
      return;
    }
    let nextCard = this.getNextStateCard();
    let conceptCard = this.conceptCardManagerService.getConceptCard();
    if (
      this.displayedCard.isCompleted() &&
      nextCard.getStateName() === this.displayedCard.getStateName() &&
      conceptCard
    ) {
      this._recordNewCardAdded();
      this._addNewCard(
        StateCard.createNewCard(
          '',
          conceptCard.getExplanation().html,
          '',
          new Interaction([], [], {}, null, [], null, null),
          ''
        )
      );
      return;
    }
    if (this.isLearnAgainButton()) {
      const indexOfRevisionCard =
        this.playerTranscriptService.findIndexOfLatestStateWithName(
          nextCard.getStateName()
        );
      if (indexOfRevisionCard !== null) {
        this.displayedCard.markAsNotCompleted();
        this._changeCard(indexOfRevisionCard);
        return;
      }
    }
    /* This is for the following situation:
        if A->B->C is the arrangement of cards and C redirected to A,
        then after this, B and C are visited cards and hence
        pendingCardWasSeenBefore would be true during both these
        transitions and as answerIsCorrect is set to false below,
        Continue would briefly change to Learn Again (after it is
        clicked) during these transitions which is not required.
        Also, if the 'if' check is not there, Learn Again button would
        briefly switched to Continue before going to next card. */
    if (this.getAnswerIsCorrect()) {
      this.pendingCardWasSeenBefore = false;
    }
    this.setAnswerIsCorrect(false);
    this.showPendingCard();
  }

  /**
   * Displays the next pending card in the conversation flow.
   *
   * - Records that a new card has been added.
   * - Schedules the card transition animation and adds the new card once complete.
   * - Emits an event indicating that a new card has been opened.
   *
   * @returns {void}
   */
  showPendingCard(): void {
    this._recordNewCardAdded();
    this.cardAnimationService.scheduleNextCardTransition(
      this._nextFocusLabel,
      () => {
        let nextCard = this.getNextStateCard();
        this._addNewCard(nextCard);
      }
    );
    let nextCard = this.getNextStateCard();
    if (nextCard === null) {
      throw new Error('Next card cannot be null when showing pending card.');
    }
    this.playerPositionService.onNewCardOpened.emit(nextCard);
  }

  /**
   * Updates the card layout based on whether supplemental cards are non-empty
   * and screen size allows for two-card display.     *
   */
  _updateCardLayout(): void {
    const totalNumCards = this.playerTranscriptService.getNumCards();
    const prevNonempty =
      totalNumCards > 1 &&
      this.isSupplementalCardNonempty(
        this.playerTranscriptService.getCard(totalNumCards - 2)
      );
    const nextNonempty = this.isSupplementalCardNonempty(
      this.playerTranscriptService.getLastCard()
    );

    if (
      totalNumCards > 1 &&
      this.cardAnimationService.canWindowShowTwoCards()
    ) {
      if (!prevNonempty && nextNonempty) {
        this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);
        this.cardAnimationService.animateToTwoCards();
        return;
      } else if (prevNonempty && !nextNonempty) {
        this.cardAnimationService.animateToOneCard();
        return;
      }
    }
    this.playerPositionService.setDisplayedCardIndex(totalNumCards - 1);
  }

  /**
   * Records the addition of a new card in the current engine service.
   */
  private _recordNewCardAdded(): void {
    let currentEngineService =
      this.currentEngineService.getCurrentEngineService();
    return currentEngineService.recordNewCardAdded();
  }

  /**
   * Retrieves the language code of the exploration from the current engine service.
   *
   * @returns {string} The language code of the exploration.
   */
  private _getLanguageCode(): string {
    let currentEngineService =
      this.currentEngineService.getCurrentEngineService();
    return currentEngineService.getLanguageCode();
  }

  /**
   * Returns the focus label for content elements, used to manage
   * focus during dynamic card navigation.
   *
   * @param {number} index - The index to append to the content focus label prefix.
   * @returns {string} The content focus label string.
   */
  private _getContentFocusLabel(index: number): string {
    return ExplorationPlayerConstants.CONTENT_FOCUS_LABEL_PREFIX + index;
  }

  /**
   * Records that the learner is leaving the current exploration to view
   * a refresher exploration, for analytics and progress tracking purposes.
   *
   * This event is only recorded when the learner is in the learner view,
   * not in the exploration editor preview mode.
   *
   * @param {string} refresherExpId - The ID of the refresher exploration
   *   the learner is navigating to.
   */
  private _recordLeaveForRefresherExp(refresherExpId: string): void {
    let editorPreviewMode = this.pageContextService.isInExplorationEditorPage();
    if (!editorPreviewMode) {
      this.statsReportingService.recordLeaveForRefresherExp(
        this.playerPositionService.getCurrentStateName(),
        refresherExpId
      );
    }
  }

  /**
   * Handles the display of feedback to the learner while staying on the current card.
   * This method is called when an answer is submitted and the system decides to give feedback
   * instead of moving to the next state (e.g., due to an incorrect answer or missing prerequisite).
   *
   * It:
   * - Records the incorrect answer
   * - Displays feedback and help cards if applicable
   * - Loads concept cards if a prerequisite skill is missing
   * - Optionally refreshes the interaction UI
   * - Optionally prompts for redirection to a refresher exploration
   *
   * @param {string | null} feedbackHtml - HTML string containing feedback to show to the learner.
   *     If null, no feedback is shown.
   * @param {string | null} missingPrerequisiteSkillId - The ID of a prerequisite skill the learner
   *     needs to revisit. If provided, triggers concept card loading.
   * @param {boolean} refreshInteraction - Whether the interaction should be visually refreshed
   *     (e.g., to give a new randomized version of the same interaction).
   * @param {string | null} refresherExplorationId - If provided, prompts the learner to redirect to
   *     a refresher exploration. Otherwise, no redirection is offered.
   */
  private _giveFeedbackAndStayOnCurrentCard(
    feedbackHtml: string,
    missingPrerequisiteSkillId: string | null,
    refreshInteraction: boolean,
    refresherExplorationId: string | null
  ): void {
    this._recordIncorrectAnswer();
    this.playerTranscriptService.addNewResponse(feedbackHtml);
    let helpCardAvailable =
      feedbackHtml && !this.displayedCard.isInteractionInline();

    if (helpCardAvailable) {
      this._emitHelpCard(feedbackHtml, false);
    }
    if (missingPrerequisiteSkillId) {
      this.displayedCard.markAsCompleted();
      this.conceptCardBackendApiService
        .loadConceptCardsAsync([missingPrerequisiteSkillId])
        .then(conceptCardObject => {
          this.conceptCardManagerService.setConceptCard(conceptCardObject[0]);
          if (helpCardAvailable) {
            this._emitHelpCard(feedbackHtml, true);
          }
        });
    }
    if (refreshInteraction) {
      // Replace the previous interaction with another of the
      // same type.
      this.playerTranscriptService.updateLatestInteractionHtml(
        this.displayedCard.getInteractionHtml() +
          this.explorationEngineService.getRandomSuffix()
      );
    }

    this.redirectToRefresherExplorationConfirmed = false;

    if (refresherExplorationId) {
      // TODO(bhenning): Add tests to verify the event is
      // properly recorded.
      const confirmRedirection = () => {
        this.redirectToRefresherExplorationConfirmed = true;
        this._recordLeaveForRefresherExp(refresherExplorationId);
      };
      this.explorationSummaryBackendApiService
        .loadPublicExplorationSummariesAsync([refresherExplorationId])
        .then(response => {
          if (response.summaries.length > 0) {
            this.refresherExplorationConfirmationModalService.displayRedirectConfirmationModal(
              refresherExplorationId,
              confirmRedirection
            );
          }
        });
    }
  }

  /**
   * Changes the currently displayed card to the specified index.
   *
   * This method records the navigation action, updates the displayed card index,
   * notifies the state editor (if in editor mode), and sets the corresponding
   * question based on the index.
   *
   * @param index - The index of the card to be displayed.
   */
  private _changeCard(index: number): void {
    this.playerPositionService.recordNavigationButtonClick();
    this.playerPositionService.setDisplayedCardIndex(index);
    this.stateEditorService.onUpdateActiveStateIfInEditor.emit(
      this.playerPositionService.getCurrentStateName()
    );
    this.playerPositionService.changeCurrentQuestion(index);
  }

  /**
   * Navigates the learner to the most recently reached checkpoint in
   * the exploration. It:
   * - Loads the latest exploration states.
   * - Determines the most recently reached checkpoint (either from local service or backend).
   * - Reconstructs the path to that checkpoint.
   * - Adds the corresponding cards to the transcript.
   * - Updates checkpoint progress.
   * - Moves the learner to the appropriate card in the UI.
   *
   * Used when the learner resumes an in-progress exploration with checkpoints.
   */
  private _navigateToMostRecentlyReachedCheckpoint(): void {
    let states: StateObjectsBackendDict;
    let pidInUrl = this.urlService.getPidFromUrl();
    let explorationId = this.pageContextService.getExplorationId();
    this.readOnlyExplorationBackendApiService
      .loadLatestExplorationAsync(explorationId, pidInUrl)
      .then(response => {
        states = response.exploration.states;

        let mostRecentlyReachedCheckpoint =
          this.checkpointProgressService.getMostRecentlyReachedCheckpoint() ||
          response.most_recently_reached_checkpoint_state_name;

        this.checkpointProgressService.setMostRecentlyReachedCheckpoint(
          mostRecentlyReachedCheckpoint
        );

        let prevSessionStatesProgress =
          this.explorationEngineService.getShortestPathToState(
            states,
            mostRecentlyReachedCheckpoint
          );

        let indexToRedirectTo = 0;

        for (let i = 0; i < prevSessionStatesProgress.length; i++) {
          // Set state name of a previously completed state.
          let stateName = prevSessionStatesProgress[i];
          let stateData =
            this.explorationEngineService.getStateFromStateName(stateName);

          // Skip the card if it has already been added to transcript.
          if (
            !this.playerTranscriptService.hasEncounteredStateBefore(stateName)
          ) {
            let stateCard =
              this.explorationEngineService.getStateCardByName(stateName);
            this._addNewCard(stateCard);
          }

          if (
            !this.checkpointProgressService.checkIfCheckpointIsVisited(
              stateName
            ) &&
            stateData.cardIsCheckpoint
          ) {
            this.checkpointProgressService.setVisitedCheckpointStateNames(
              stateName
            );
          }

          if (mostRecentlyReachedCheckpoint === stateName) {
            break;
          }

          indexToRedirectTo += 1;
        }

        // Remove the last card from progress as it is not completed
        // yet and is only most recently reached.
        prevSessionStatesProgress.pop();
        this.playerTranscriptService.setPrevSessionStatesProgress(
          prevSessionStatesProgress
        );

        if (indexToRedirectTo > 0) {
          setTimeout(() => {
            let alertInfoElement = document.querySelector(
              '.oppia-exploration-checkpoints-message'
            );

            // Remove the alert message after 6 sec.
            if (alertInfoElement) {
              alertInfoElement.remove();
            }
          }, ExplorationPlayerConstants.ALERT_MESSAGE_TIMEOUT);
        }

        // Move to most recently reached checkpoint card.
        this._changeCard(indexToRedirectTo);
        this.playerPositionService.onLoadedMostRecentCheckpoint.emit();
      });
  }

  /**
   * Handles the transition to a new card in the exploration after an answer
   * has been submitted. Depending on whether it's the final question or not,
   * and whether feedback is available, it:
   * - Displays the feedback if present.
   * - Emits help card and card availability events.
   * - Scrolls to bottom or focuses continue button.
   * - Marks the current card as completed.
   * - Either moves to a new card or shows the pending card.
   *
   * @param {string | null} feedbackHtml - The feedback HTML to display, if any.
   * @param {boolean} isFinalQuestion - Whether the current question is the last one.
   */
  private _moveToNewCard(
    feedbackHtml: string | null,
    isFinalQuestion: boolean
  ): void {
    // There is a new card. If there is no feedback, move on
    // immediately. Otherwise, give the learner a chance to read
    // the feedback, and display a 'Continue' button.
    this.pendingCardWasSeenBefore = false;
    this.displayedCard.markAsCompleted();
    if (isFinalQuestion) {
      if (this.explorationModeService.isInQuestionPlayerMode()) {
        // We will redirect to the results page here.
        this.questionSessionCompleted = true;
      }
      this.moveToExploration = true;
      if (feedbackHtml) {
        this.playerTranscriptService.addNewResponse(feedbackHtml);
        if (!this.displayedCard.isInteractionInline()) {
          this.playerPositionService.onHelpCardAvailable.emit({
            helpCardHtml: feedbackHtml,
            hasContinueButton: true,
          });
        }
      } else {
        this.showUpcomingCard();
      }
      this.setAnswerIsBeingProcessed(false);
      return;
    }
    this.fatigueDetectionService.reset();
    this.numberAttemptsService.reset();

    let nextCard = this.getNextStateCard();

    if (feedbackHtml) {
      if (
        this.playerTranscriptService.hasEncounteredStateBefore(
          nextCard.getStateName()
        )
      ) {
        this.pendingCardWasSeenBefore = true;
      }
      this.playerTranscriptService.addNewResponse(feedbackHtml);
      if (!this.displayedCard.isInteractionInline()) {
        this.playerPositionService.onHelpCardAvailable.emit({
          helpCardHtml: feedbackHtml,
          hasContinueButton: true,
        });
      }
      this.playerPositionService.onNewCardAvailable.emit();
      this._nextFocusLabel =
        ExplorationPlayerConstants.CONTINUE_BUTTON_FOCUS_LABEL;
      this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);
      this.cardAnimationService.scrollToBottom();
    } else {
      this.playerTranscriptService.addNewResponse(feedbackHtml);
      // If there is no feedback, it immediately moves on
      // to next card. Therefore this.answerIsCorrect needs
      // to be set to false before it proceeds to next card.
      this.answerIsCorrect = false;
      this.showPendingCard();
    }
    this.currentInteractionService.clearPresubmitHooks();
  }

  /**
   * Adds a new card to the transcript and updates the UI layout.
   * If the previously displayed card is terminal, handles terminal card logic.
   *
   * @param newCard - The new card object to be added to the transcript.
   */
  private _addNewCard(newCard: StateCard): void {
    this.playerTranscriptService.addNewCard(newCard);
    this._shouldDisplayTranslation();
    this._updateCardLayout();

    this.playerPositionService.changeCurrentQuestion(
      this.playerPositionService.getDisplayedCardIndex()
    );

    if (this.displayedCard && this.displayedCard.isTerminal()) {
      this._handleTerminalCard(this.displayedCard);
    }
  }

  /**
   * Handles logic to be executed when the displayed card is a terminal card.
   * Determines recommendation strategy based on parent explorations and story mode.
   *
   * @param displayedCard - The terminal card currently displayed to the user.
   */
  private _handleTerminalCard(displayedCard: StateCard): void {
    this.setIsRefresherExploration(false);
    const parentExplorationIds =
      this.urlService.getQueryFieldValuesAsList('parent');
    this.setParentExplorationIds(parentExplorationIds);
    let recommendedExplorationIds = [];
    let includeAutogeneratedRecommendations = false;

    if (parentExplorationIds.length > 0) {
      this.setIsRefresherExploration(true);
      let parentExplorationId =
        parentExplorationIds[parentExplorationIds.length - 1];
      recommendedExplorationIds.push(parentExplorationId);
    } else {
      recommendedExplorationIds =
        this.explorationEngineService.getAuthorRecommendedExpIdsByStateName(
          displayedCard.getStateName()
        );
      includeAutogeneratedRecommendations = true;
    }

    if (this.explorationModeService.isInStoryChapterMode()) {
      recommendedExplorationIds = [];
      this._handleStoryModeTerminalCard();
    } else {
      this._fetchAndDisplayRecommendations(
        includeAutogeneratedRecommendations,
        recommendedExplorationIds
      );
    }

    this._shouldShowProgressClearanceMessage();
  }

  /**
   * Handles terminal card logic specific to story chapter mode.
   * Fetches the next chapter, sets recommendations, and records chapter completion.
   * Redirects to review tests if ready.
   */
  private _handleStoryModeTerminalCard(): void {
    const topicUrlFragment = this.urlService.getUrlParams().topic_url_fragment;
    const classroomUrlFragment =
      this.urlService.getUrlParams().classroom_url_fragment;
    const storyUrlFragment = this.urlService.getUrlParams().story_url_fragment;
    const nodeId = this.urlService.getUrlParams().node_id;

    this.storyViewerBackendApiService
      .fetchStoryDataAsync(
        topicUrlFragment,
        classroomUrlFragment,
        storyUrlFragment
      )
      .then(res => {
        for (let i = 0; i < res.nodes.length; i++) {
          if (res.nodes[i].id === nodeId && i + 1 < res.nodes.length) {
            this.explorationRecommendationsService.setRecommendedStoryNodeId(
              res.nodes[i].destinationNodeIds[0]
            );
            this.recommendedExplorationSummaries = [
              res.nodes[i + 1].explorationSummary,
            ];
            break;
          }
        }
      });

    if (this.isLoggedIn) {
      this.storyViewerBackendApiService
        .recordChapterCompletionAsync(
          topicUrlFragment,
          classroomUrlFragment,
          storyUrlFragment,
          nodeId
        )
        .then(returnObject => {
          if (returnObject.readyForReviewTest) {
            (
              this.windowRef.nativeWindow as {location: string | Location}
            ).location = this.urlInterpolationService.interpolateUrl(
              TopicViewerDomainConstants.REVIEW_TESTS_URL_TEMPLATE,
              {
                topic_url_fragment: topicUrlFragment,
                classroom_url_fragment: classroomUrlFragment,
                story_url_fragment: storyUrlFragment,
              }
            );
          }
          this.chapterProgressService.updateCompletedChaptersCount(true);
        });
    } else {
      const redirectUrl = this.urlInterpolationService.interpolateUrl(
        StoryViewerDomainConstants.STORY_PROGRESS_URL_TEMPLATE,
        {
          topic_url_fragment: topicUrlFragment,
          classroom_url_fragment: classroomUrlFragment,
          story_url_fragment: storyUrlFragment,
          node_id: nodeId,
        }
      );
      this.userService.setReturnUrl(redirectUrl);
    }
  }

  /**
   * Fetches and displays recommended exploration summaries.
   *
   * @param includeAutogeneratedRecommendations - Whether to include auto-generated recommendations.
   * @param recommendedExplorationIds - The list of exploration IDs to recommend.
   */
  private _fetchAndDisplayRecommendations(
    includeAutogeneratedRecommendations: boolean,
    recommendedExplorationIds: string[]
  ): void {
    this.explorationRecommendationsService.getRecommendedSummaryDicts(
      recommendedExplorationIds,
      includeAutogeneratedRecommendations,
      /* istanbul ignore next */
      summaries => {
        this.recommendedExplorationSummaries = summaries;
      }
    );
  }

  /**
   * Displays a one-time message to the user that progress can be cleared.
   * Automatically removes the message after a timeout.
   */
  private _shouldShowProgressClearanceMessage(): void {
    if (!this.showProgressClearanceMessage) {
      this.showProgressClearanceMessage = true;
      setTimeout(() => {
        const el = document.querySelector(
          '.oppia-exploration-checkpoints-message'
        );
        /* istanbul ignore if */
        if (el) {
          el.remove();
        }
      }, ExplorationPlayerConstants.ALERT_MESSAGE_TIMEOUT);
    }
  }

  /**
   * Checks if the current content language differs from the exploration's
   * original language. If so, triggers the display of available translations.
   *
   * @private
   */
  private _shouldDisplayTranslation(): void {
    const explorationLanguage = this._getLanguageCode();
    const selectedLanguage =
      this.contentTranslationLanguageService.getCurrentContentLanguageCode();
    if (explorationLanguage !== selectedLanguage) {
      this.contentTranslationManagerService.displayTranslations(
        selectedLanguage
      );
    }
  }

  /**
   * Handles the response after submitting an answer, including:
   * - Updating state card
   * - Emitting analytics and state transitions
   * - Triggering voiceovers and feedback
   * - Advancing to the next card or staying on the current one
   *
   * @param {{
   *   displayedCard: StateCard,
   *   editorPreviewMode: boolean,
   *   nextCard: StateCard,
   *   refreshInteraction: boolean,
   *   feedbackHtml: string,
   *   refresherExplorationId: string | null,
   *   missingPrerequisiteSkillId: string,
   *   remainOnCurrentCard: boolean,
   *   taggedSkillMisconceptionId: string,
   *   wasOldStateInitial: boolean,
   *   isFirstHit: boolean,
   *   isFinalQuestion: boolean,
   *   nextCardIfReallyStuck: StateCard | null,
   *   focusLabel: string,
   *   timeAtServerCall: number,
   *   currentEngineService
   * }} responseData - The full answer response context.
   *
   * @private
   */
  private _handleAnswerResponse({
    displayedCard,
    editorPreviewMode,
    nextCard,
    refreshInteraction,
    feedbackHtml,
    refresherExplorationId,
    missingPrerequisiteSkillId,
    remainOnCurrentCard,
    taggedSkillMisconceptionId,
    wasOldStateInitial,
    isFirstHit,
    isFinalQuestion,
    nextCardIfReallyStuck,
    focusLabel,
    timeAtServerCall,
    currentEngineService,
  }: AnswerResponseData): void {
    this.setNextStateCard(nextCard);
    this.setNextCardIfStuck(nextCardIfReallyStuck);

    if (
      !editorPreviewMode &&
      !this.explorationModeService.isPresentingIsolatedQuestions()
    ) {
      const oldStateName = this.playerPositionService.getCurrentStateName();
      const completedChaptersCount =
        this.chapterProgressService.getCompletedChaptersCount();

      if (!remainOnCurrentCard) {
        let lastAnswer = displayedCard.getLastAnswer();
        this.statsReportingService.recordStateTransition(
          oldStateName,
          nextCard.getStateName(),
          lastAnswer,
          this.learnerParamsService.getAllParams(),
          isFirstHit,
          String(completedChaptersCount && completedChaptersCount + 1),
          String(this.playerTranscriptService.getNumCards()),
          currentEngineService.getLanguageCode()
        );
        this.statsReportingService.recordStateCompleted(oldStateName);
      }

      if (nextCard.isTerminal()) {
        this.statsReportingService.recordStateCompleted(
          nextCard.getStateName()
        );
      }

      if (wasOldStateInitial && !this.explorationActuallyStarted) {
        this.statsReportingService.recordExplorationActuallyStarted(
          oldStateName
        );
        this.explorationActuallyStarted = true;
      }
    }

    if (!this.explorationModeService.isPresentingIsolatedQuestions()) {
      this.onPlayerStateChange.emit(nextCard.getStateName());
    } else if (this.explorationModeService.isInQuestionPlayerMode()) {
      this.questionPlayerEngineService.recordAnswerSubmitted(
        this.questionPlayerEngineService.getCurrentQuestion(),
        !remainOnCurrentCard,
        taggedSkillMisconceptionId
      );
    }

    const millisecsLeftToWait = this._calculateDelayForNextCard(
      displayedCard,
      timeAtServerCall
    );

    setTimeout(() => {
      this.onOppiaFeedbackAvailable.emit();
      this._setActiveVoiceover(feedbackHtml);

      if (remainOnCurrentCard) {
        this._giveFeedbackAndStayOnCurrentCard(
          feedbackHtml,
          missingPrerequisiteSkillId,
          refreshInteraction,
          refresherExplorationId
        );
        if (refreshInteraction) {
          this._nextFocusLabel = this.focusManagerService.generateFocusLabel();
        }
        this.focusManagerService.setFocusIfOnDesktop(this._nextFocusLabel);
        this.cardAnimationService.scrollToBottom();
      } else {
        this._moveToNewCard(feedbackHtml, isFinalQuestion);
      }

      this.answerIsBeingProcessed = false;
    }, millisecsLeftToWait);
  }

  /**
   * Calculates the appropriate delay before transitioning to the next card,
   * ensuring a minimum load time unless the interaction is supplemental
   * or part of a diagnostic test.
   *
   * @param {StateCard} displayedCard - The current displayed card.
   * @param {number} timeAtServerCall - Timestamp when server call was made.
   * @returns {number} Time in milliseconds to delay.
   *
   * @private
   */
  private _calculateDelayForNextCard(
    displayedCard: StateCard,
    timeAtServerCall: number
  ): number {
    if (
      !displayedCard.isInteractionInline() ||
      this.explorationModeService.isInDiagnosticTestPlayerMode()
    ) {
      return 1.0;
    }
    return Math.max(
      ExplorationPlayerConstants.MIN_CARD_LOADING_DELAY_MSEC -
        (Date.now() - timeAtServerCall),
      1.0
    );
  }

  /**
   * Initializes the learner answer info service, if applicable, to collect
   * more details from the learner for analytics or clarification.
   *
   * @param {boolean} isPreviewMode - Whether the app is in preview/editor mode.
   * @param {string} explorationId - The ID of the current exploration.
   * @param {string} answer - The learner's submitted answer.
   * @param {InteractionRulesService} interactionRulesService - Rules for validating interactions.
   *
   * @private
   */
  private _shouldInitLearnerAnswerInfo(
    isPreviewMode: boolean,
    explorationId: string,
    answer: string,
    interactionRulesService: InteractionRulesService
  ): void {
    /* istanbul ignore if */
    if (
      isPreviewMode ||
      this.explorationModeService.isPresentingIsolatedQuestions() ||
      !AppConstants.ENABLE_SOLICIT_ANSWER_DETAILS_FEATURE
    ) {
      return;
    }

    this.learnerAnswerInfoService.initLearnerAnswerInfoService(
      explorationId,
      this.explorationEngineService.getState(),
      answer,
      interactionRulesService
    );
  }

  /**
   * Updates the state and internal services when a learner submits an answer.
   * Includes incrementing attempt counters and marking the submission as in-progress.
   *
   * @param {string} answer - The learner's answer.
   *
   * @private
   */
  private _updateAnswerSubmissionState(answer: string): void {
    this.numberAttemptsService.submitAttempt();
    this.answerIsBeingProcessed = true;
    this.hasInteractedAtLeastOnce = true;
    this.playerTranscriptService.addNewInput(answer, false);
    this.playerPositionService.recordAnswerSubmission();
  }

  /**
   * Checks if the learner is submitting answers too quickly (fatigue detection).
   * If true, displays a warning message and blocks further submissions temporarily.
   *
   * @returns {boolean} Whether the submission should be blocked due to rapid input.
   *
   * @private
   */
  private _isSubmittingTooFast(): boolean {
    this.fatigueDetectionService.recordSubmissionTimestamp();
    if (this.fatigueDetectionService.isSubmittingTooFast()) {
      this.fatigueDetectionService.displayTakeBreakMessage();
      this.onOppiaFeedbackAvailable.emit();
      return true;
    }
    return false;
  }

  /**
   * Determines whether answer submission should be blocked based on:
   * - Submission in progress
   * - Not at the end of the transcript
   * - Card already completed
   *
   * @param {StateCard} card - The current interaction card.
   * @returns {boolean} Whether submission is currently disallowed.
   *
   * @private
   */
  private _shouldBlockSubmission(card: StateCard): boolean {
    return (
      this.answerIsBeingProcessed ||
      !this.playerPositionService.isCurrentCardAtEndOfTranscript() ||
      card.isCompleted()
    );
  }

  /**
   * Performs the stuck check logic. If the learner is stuck on the card and
   * a stuck state card (`nextCardIfStuck`) exists, shows a redirection message
   * and invokes the callback to display the revision button.
   *
   * Alternatively, if the learner has reached the maximum number of incorrect
   * attempts, the solution is revealed (if available).
   *
   * @param {() => void} onShowContinueToReviseButton - Callback to show
   *   the "Continue to revise" button.
   */
  private _performStuckCheck(onShowContinueToReviseButton: () => void): void {
    const numberOfIncorrectSubmissions =
      this.playerTranscriptService.getNumberOfIncorrectSubmissions();

    if (this.nextCardIfStuck && this.nextCardIfStuck !== this.displayedCard) {
      this.playerTranscriptService.addNewResponseToExistingFeedback(
        this.translateService.instant('I18N_REDIRECTION_TO_STUCK_STATE_MESSAGE')
      );
      onShowContinueToReviseButton();
    } else if (
      this.solutionForState !== null &&
      numberOfIncorrectSubmissions >=
        ExplorationPlayerConstants.MAX_INCORRECT_ANSWERS_BEFORE_RELEASING_SOLUTION
    ) {
      this.hintsAndSolutionManagerService.releaseSolution();
    }
  }

  /**
   * Returns the currently displayed state card based on the
   * learner's current position in the transcript.
   *
   * @returns {StateCard} The currently displayed exploration card.
   */
  private _getCurrentCard(): StateCard {
    let index = this.playerPositionService.getDisplayedCardIndex();
    let displayedCard = this.playerTranscriptService.getCard(index);
    return displayedCard;
  }

  /**
   * Records that the user has submitted an incorrect answer.
   *
   * This method updates multiple services to reflect the incorrect submission:
   * - Increments the count of incorrect submissions in the transcript.
   * - Notifies the hints and solution manager for potential hint logic.
   * - Notifies the concept card manager, possibly for tracking misconceptions.
   */
  private _recordIncorrectAnswer(): void {
    this.playerTranscriptService.incrementNumberOfIncorrectSubmissions();
    this.hintsAndSolutionManagerService.recordWrongAnswer();
    this.conceptCardManagerService.recordWrongAnswer();
  }

  /**
   * Emits a help card to be displayed to the user.
   *
   * This method notifies the system that a help card is available,
   * providing its HTML content and whether it includes a "Continue" button.
   *
   * @param helpCardHtml - The HTML content of the help card.
   * @param hasContinueButton - Whether the help card includes a continue button.
   */
  private _emitHelpCard(
    helpCardHtml: string,
    hasContinueButton: boolean
  ): void {
    this.playerPositionService.onHelpCardAvailable.emit({
      helpCardHtml: helpCardHtml,
      hasContinueButton: hasContinueButton,
    });
  }

  /**
   * Sets the active voiceover for the given feedback HTML, if a matching content ID is found.
   * Also sets the active component name to 'feedback' and triggers autoplay for the audio.
   *
   * @param {string} feedbackHtml - The HTML content of the feedback to match against interaction content IDs.
   * @returns {void}
   */
  private _setActiveVoiceover(feedbackHtml: string): void {
    let interaction = this.displayedCard.getInteraction();

    let feedbackContentId =
      interaction.getContentIdForMatchingHtml(feedbackHtml);

    /* istanbul ignore if */
    if (feedbackContentId) {
      this.voiceoverPlayerService.setActiveVoiceover(feedbackContentId);
    }
    this.voiceoverPlayerService.setActiveComponentName(
      AppConstants.COMPONENT_NAME_FEEDBACK
    );

    this.audioPlayerService.onAutoplayAudio.emit();
  }

  /**
   * Validates the given index before changing to the corresponding card.
   *
   * Ensures that the target index is within the bounds of the player transcript.
   * If valid, it proceeds to change the card. Otherwise, it throws an error.
   *
   * This method is used to safely navigate through previously seen cards only.
   *
   * @param index - The index of the card to validate and display.
   * @throws Will throw an error if the index is out of bounds.
   */
  private _validateIndexAndChangeCard(index: number): void {
    let transcriptLength = this.playerTranscriptService.getNumCards();
    if (index >= 0 && index < transcriptLength) {
      this._changeCard(index);
    } else {
      throw new Error('Target card index out of bounds.');
    }
  }

  /**
   * Checks if the user has confirmed redirection to a refresher exploration.
   *
   * @returns {boolean} True if the user has confirmed redirection, false otherwise.
   */
  getRedirectToRefresherExplorationConfirmed(): boolean {
    return this.redirectToRefresherExplorationConfirmed;
  }

  /**
   * Sets whether the user has confirmed redirection to a refresher exploration.
   *
   * @param {boolean} confirmed - True if the user has confirmed redirection, false otherwise.
   */
  setRedirectToRefresherExplorationConfirmed(confirmed: boolean): void {
    this.redirectToRefresherExplorationConfirmed = confirmed;
  }

  /**
   * Checks if the current exploration is a refresher exploration.
   *
   * @returns {boolean} True if the current exploration is a refresher exploration, false otherwise.
   */
  getIsRefresherExploration(): boolean {
    return this.isRefresherExploration;
  }

  /**
   * Sets whether the current exploration is a refresher exploration.
   *
   * @param {boolean} isRefresher - True if the current exploration is a refresher exploration, false otherwise.
   */
  setIsRefresherExploration(isRefresher: boolean): void {
    this.isRefresherExploration = isRefresher;
  }

  /**
   * Sets the parent exploration IDs for the current exploration.
   *
   * @param {string[]} parentExplorationIds - An array of parent exploration IDs.
   */
  setParentExplorationIds(parentExplorationIds: string[]): void {
    this.parentExplorationIds = [...parentExplorationIds];
  }

  /**
   * Retrieves the parent exploration IDs for the current exploration.
   *
   * @returns {string[]} An array of parent exploration IDs.
   */
  getParentExplorationIds(): string[] {
    return this.parentExplorationIds;
  }

  /**
   * Retrieves the next card to be displayed if the user is stuck.
   * This card will be shown when the user is unable to progress further.
   *
   * @returns {StateCard | null} The next card if stuck, or null if none is set.
   */
  getNextCardIfStuck(): StateCard | null {
    return this.nextCardIfStuck;
  }

  /**
   * Sets the next card to be displayed if the user is stuck.
   * This card will be shown when the user is unable to progress further.
   *
   * @param {StateCard | null} card - The card to set as the next card if stuck.
   */
  setNextCardIfStuck(card: StateCard | null): void {
    this.nextCardIfStuck = card;
  }

  /**
   * Sets the solution for the current state.
   *
   * @param {Solution | null} solution - The solution to set for the current state.
   */
  setSolutionForState(solution: Solution | null): void {
    this.solutionForState = solution;
  }

  /**
   * Retrieves the solution for the current state.
   *
   * @returns {Solution | null} The solution for the current state, or null if none is set.
   */
  getSolutionForState(): Solution | null {
    return this.solutionForState;
  }

  /**
   * Retrieves the next state card to be displayed.
   *
   * @returns {StateCard | null} The next state card, or null if none is set.
   */
  getNextStateCard(): StateCard {
    return this.nextStateCard;
  }

  /**
   * Sets the next state card to be displayed.
   *
   * @param {StateCard | null} card - The next state card to set, or null if none.
   */
  setNextStateCard(card: StateCard): void {
    this.nextStateCard = card;
  }
  /**
   * Returns whether the answer is marked as correct.
   * @returns {boolean} `true` if the answer is correct, otherwise `false`.
   */
  getAnswerIsCorrect(): boolean {
    return this.answerIsCorrect;
  }

  /**
   * Sets whether the answer is correct.
   * @param {boolean} isCorrect - `true` if the answer is correct, otherwise `false`.
   */
  setAnswerIsCorrect(isCorrect: boolean): void {
    this.answerIsCorrect = isCorrect;
  }

  /**
   * Returns whether the answer is currently being processed.
   * @returns {boolean} `true` if the answer is being processed, otherwise `false`.
   */
  getAnswerIsBeingProcessed(): boolean {
    return this.answerIsBeingProcessed;
  }

  /**
   * Sets whether the answer is currently being processed.
   * @param {boolean} isBeingProcessed - `true` if the answer is being processed, otherwise `false`.
   */
  setAnswerIsBeingProcessed(isBeingProcessed: boolean): void {
    this.answerIsBeingProcessed = isBeingProcessed;
  }

  /**
   * Returns whether the user has interacted at least once.
   * @returns {boolean} `true` if the user has interacted at least once, otherwise `false`.
   */
  getHasInteractedAtLeastOnce(): boolean {
    return this.hasInteractedAtLeastOnce;
  }

  /**
   * Sets whether the learner has interacted with the exploration at least once.
   *
   * @param {boolean} hasInteracted - True if the learner has interacted, false otherwise.
   */
  setHasInteractedAtLeastOnce(hasInteracted: boolean): void {
    this.hasInteractedAtLeastOnce = hasInteracted;
  }

  /**
   * Returns whether the exploration has actually started.
   * @returns {boolean} True if the exploration has started, false otherwise.
   */
  getExplorationActuallyStarted(): boolean {
    return this.explorationActuallyStarted;
  }

  /**
   * Sets the flag indicating whether the exploration has actually started.
   * @param {boolean} hasStarted - True if the exploration has started, false otherwise.
   */
  setExplorationActuallyStarted(hasStarted: boolean): void {
    this.explorationActuallyStarted = hasStarted;
  }

  /**
   * Returns whether to show the progress clearance message.
   * @returns {boolean} True if the message should be shown, false otherwise.
   */
  getShowProgressClearanceMessage(): boolean {
    return this.showProgressClearanceMessage;
  }

  /**
   * Sets whether to show the progress clearance message.
   * @param {boolean} showMessage - True to show the message, false otherwise.
   */
  setShowProgressClearanceMessage(showMessage: boolean): void {
    this.showProgressClearanceMessage = showMessage;
  }

  /**
   * Returns the label for the next focus element.
   * @returns {string} The label of the next focus element.
   */
  getNextFocusLabel(): string {
    return this._nextFocusLabel;
  }

  /**
   * Returns whether the component or page has fully loaded.
   * @returns {boolean} True if fully loaded, false otherwise.
   */
  getHasFullyLoaded(): boolean {
    return this.hasFullyLoaded;
  }

  /**
   * Sets the flag indicating whether the component or page has fully loaded.
   * @param {boolean} hasLoaded - True if fully loaded, false otherwise.
   */
  setHasFullyLoaded(hasLoaded: boolean): void {
    this.hasFullyLoaded = hasLoaded;
  }

  /**
   * Returns the currently displayed state card.
   * @returns {StateCard} The currently displayed state card.
   */
  getDisplayedCard(): StateCard {
    return this.displayedCard;
  }

  /**
   * Sets the currently displayed state card.
   * @param {StateCard} card - The state card to display.
   */
  setDisplayedCard(card: StateCard): void {
    this.displayedCard = card;
  }

  /**
   * Sets the recommended exploration summaries for the learner.
   * @param {LearnerExplorationSummary[]} summaries - Array of exploration summaries.
   */
  setRecommendedExplorationSummaries(
    summaries: LearnerExplorationSummary[]
  ): void {
    this.recommendedExplorationSummaries = summaries;
  }

  /**
   * Returns the recommended exploration summaries for the learner.
   * @returns {LearnerExplorationSummary[]} Array of exploration summaries.
   */
  getRecommendedExplorationSummaries(): LearnerExplorationSummary[] {
    return this.recommendedExplorationSummaries;
  }

  /**
   * Sets the user's login status.
   * @param {boolean} userStatus - True if the user is logged in, false otherwise.
   */
  setIsLoggedIn(userStatus: boolean): void {
    this.isLoggedIn = userStatus;
  }

  get onPlayerStateChange(): EventEmitter<string> {
    return this._playerStateChangeEventEmitter;
  }

  get onOppiaFeedbackAvailable(): EventEmitter<void> {
    return this._oppiaFeedbackAvailableEventEmitter;
  }

  get onShowProgressModal(): EventEmitter<boolean> {
    return this._playerProgressModalShownEventEmitter;
  }
}
