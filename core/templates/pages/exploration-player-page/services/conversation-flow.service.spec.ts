// Copyright 2024 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Unit tests for conversation flow service.
 */

import {HttpClientTestingModule} from '@angular/common/http/testing';
import {NO_ERRORS_SCHEMA} from '@angular/core';
import {
  fakeAsync,
  TestBed,
  tick,
  waitForAsync,
  flushMicrotasks,
} from '@angular/core/testing';

import {ConversationFlowService} from './conversation-flow.service';
import {ConceptCard} from '../../../domain/skill/concept-card.model';
import {StateCard} from '../../../domain/state_card/state-card.model';
import {FatigueDetectionService} from './fatigue-detection.service';
import {SubtitledHtml} from '../../../domain/exploration/subtitled-html.model';
import {Interaction} from '../../../domain/exploration/interaction.model';
import {ConceptCardBackendApiService} from '../../../domain/skill/concept-card-backend-api.service';
import {PlayerTranscriptService} from './player-transcript.service';
import {TranslateService} from '@ngx-translate/core';
import {MockTranslateService} from '../../../components/forms/schema-based-editors/integration-tests/schema-based-editors.integration.spec';
import {ExplorationModeService} from './exploration-mode.service';
import {ExplorationEngineService} from './exploration-engine.service';
import {PageContextService} from '../../../services/page-context.service';
import {PlayerPositionService} from './player-position.service';
import {HintsAndSolutionManagerService} from './hints-and-solution-manager.service';
import {ProgressUrlService} from './progress-url.service';
import {Solution} from '../../../domain/exploration/solution.model';
import {ExplorationPlayerConstants} from '../current-lesson-player/exploration-player-page.constants';
import {CheckpointProgressService} from './checkpoint-progress.service';
import {EditableExplorationBackendApiService} from '../../../domain/exploration/editable-exploration-backend-api.service';
import {ReadOnlyExplorationBackendApiService} from '../../../domain/exploration/read-only-exploration-backend-api.service';
import {UrlService} from '../../../services/contextual/url.service';
import {AudioPlayerService} from '../../../services/audio-player.service';
import {AutogeneratedAudioPlayerService} from '../../../services/autogenerated-audio-player.service';
import {FocusManagerService} from '../../../services/stateful/focus-manager.service';
import {LoaderService} from '../../../services/loader.service';
import {I18nLanguageCodeService} from '../../../services/i18n-language-code.service';
import {WindowRef} from '../../../services/contextual/window-ref.service';
import {CardAnimationService} from './card-animation.service';
import {CurrentEngineService} from './current-engine.service';
import {NumberAttemptsService} from './number-attempts.service';
import {LearnerParamsService} from './learner-params.service';
import {StatsReportingService} from './stats-reporting.service';
import {
  ExplorationSummaryBackendApiService,
  ExplorationSummaryDict,
} from '../../../domain/summary/exploration-summary-backend-api.service';
import {
  AnswerClassificationService,
  InteractionRulesService,
} from '../services/answer-classification.service';
import {LearnerAnswerInfoService} from './learner-answer-info.service';
import {RefresherExplorationConfirmationModalService} from '../services/refresher-exploration-confirmation-modal.service';
import {ConceptCardManagerService} from './concept-card-manager.service';
import {QuestionPlayerEngineService} from './question-player-engine.service';
import {UserService} from '../../../services/user.service';

describe('Conversation flow service', () => {
  let conversationFlowService: ConversationFlowService;
  let currentEngineService: CurrentEngineService;
  let hintsAndSolutionManagerService: HintsAndSolutionManagerService;
  let urlService: UrlService;
  let questionPlayerEngineService: QuestionPlayerEngineService;
  let loaderService: LoaderService;
  let i18nLanguageCodeService: I18nLanguageCodeService;
  let cardAnimationService: CardAnimationService;
  let userService: UserService;
  let conceptCardBackendApiService: ConceptCardBackendApiService;
  let windowRef: WindowRef;
  let learnerAnswerInfoService: LearnerAnswerInfoService;
  let focusManagerService: FocusManagerService;
  let explorationSummaryBackendApiService: ExplorationSummaryBackendApiService;
  let numberAttemptsService: NumberAttemptsService;
  let statsReportingService: StatsReportingService;
  let learnerParamsService: LearnerParamsService;
  let answerClassificationService: AnswerClassificationService;
  let audioPlayerService: AudioPlayerService;
  let autogeneratedAudioPlayerService: AutogeneratedAudioPlayerService;
  let checkpointProgressService: CheckpointProgressService;
  let editableExplorationBackendApiService: EditableExplorationBackendApiService;
  let readOnlyExplorationBackendApiService: ReadOnlyExplorationBackendApiService;
  let playerTranscriptService: PlayerTranscriptService;
  let progressUrlService: ProgressUrlService;
  let refresherExplorationConfirmationModalService: RefresherExplorationConfirmationModalService;
  let explorationModeService: ExplorationModeService;
  let conceptCardManagerService: ConceptCardManagerService;
  let fatigueDetectionService: FatigueDetectionService;
  let pageContextService: PageContextService;
  let playerPositionService: PlayerPositionService;
  let explorationEngineService: ExplorationEngineService;

  let createCard = function (interactionType: string): StateCard {
    return new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], interactionType, null),
      [],
      null,
      '',
      null
    );
  };
  let displayedCard = createCard('');

  beforeEach(waitForAsync(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [
        CurrentEngineService,
        ExplorationEngineService,
        ConversationFlowService,
        {
          provide: TranslateService,
          useClass: MockTranslateService,
        },
      ],
      schemas: [NO_ERRORS_SCHEMA],
    });

    answerClassificationService = TestBed.inject(AnswerClassificationService);
    learnerParamsService = TestBed.inject(LearnerParamsService);
    numberAttemptsService = TestBed.inject(NumberAttemptsService);
    explorationSummaryBackendApiService = TestBed.inject(
      ExplorationSummaryBackendApiService
    );
    statsReportingService = TestBed.inject(StatsReportingService);
    currentEngineService = TestBed.inject(CurrentEngineService);
    conversationFlowService = TestBed.inject(ConversationFlowService);
    playerTranscriptService = TestBed.inject(PlayerTranscriptService);
    pageContextService = TestBed.inject(PageContextService);
    userService = TestBed.inject(UserService);
    fatigueDetectionService = TestBed.inject(FatigueDetectionService);
    progressUrlService = TestBed.inject(ProgressUrlService);
    hintsAndSolutionManagerService = TestBed.inject(
      HintsAndSolutionManagerService
    );
    learnerAnswerInfoService = TestBed.inject(LearnerAnswerInfoService);
    conceptCardBackendApiService = TestBed.inject(ConceptCardBackendApiService);
    questionPlayerEngineService = TestBed.inject(QuestionPlayerEngineService);
    loaderService = TestBed.inject(LoaderService);
    i18nLanguageCodeService = TestBed.inject(I18nLanguageCodeService);
    cardAnimationService = TestBed.inject(CardAnimationService);
    windowRef = TestBed.inject(WindowRef);
    editableExplorationBackendApiService = TestBed.inject(
      EditableExplorationBackendApiService
    );
    refresherExplorationConfirmationModalService = TestBed.inject(
      RefresherExplorationConfirmationModalService
    );
    readOnlyExplorationBackendApiService = TestBed.inject(
      ReadOnlyExplorationBackendApiService
    );
    conceptCardManagerService = TestBed.inject(ConceptCardManagerService);
    urlService = TestBed.inject(UrlService);
    audioPlayerService = TestBed.inject(AudioPlayerService);
    autogeneratedAudioPlayerService = TestBed.inject(
      AutogeneratedAudioPlayerService
    );
    checkpointProgressService = TestBed.inject(CheckpointProgressService);
    focusManagerService = TestBed.inject(FocusManagerService);
    editableExplorationBackendApiService = TestBed.inject(
      EditableExplorationBackendApiService
    );
    readOnlyExplorationBackendApiService = TestBed.inject(
      ReadOnlyExplorationBackendApiService
    );
    playerPositionService = TestBed.inject(PlayerPositionService);
    hintsAndSolutionManagerService = TestBed.inject(
      HintsAndSolutionManagerService
    );

    explorationModeService = TestBed.inject(ExplorationModeService);
    explorationEngineService = TestBed.inject(ExplorationEngineService);
    conversationFlowService = TestBed.inject(ConversationFlowService);
    playerTranscriptService = TestBed.inject(PlayerTranscriptService);

    spyOn(pageContextService, 'getExplorationId').and.returnValue('expId');
  }));

  it('should tell if supplemental card is non empty', () => {
    expect(
      conversationFlowService.isSupplementalCardNonempty(displayedCard)
    ).toBeFalse();

    let textInputCard = createCard('TextInput');
    expect(
      conversationFlowService.isSupplementalCardNonempty(textInputCard)
    ).toBeFalse();

    let supplementaryImageInputCard = createCard('ImageClickInput');
    expect(
      conversationFlowService.isSupplementalCardNonempty(
        supplementaryImageInputCard
      )
    ).toBeTrue();
  });

  it('should return to exploration after concept card if last card is shown', () => {
    const mockDisplayedCard = jasmine.createSpyObj('StateCard', [
      'getStateName',
    ]);
    mockDisplayedCard.getStateName.and.returnValue(null);

    conversationFlowService.displayedCard = mockDisplayedCard;

    spyOn(explorationModeService, 'isInQuestionMode').and.returnValue(false);
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);
    const returnToExplorationSpy = spyOn(
      conceptCardManagerService,
      'returnToExplorationAfterConceptCard'
    );

    conversationFlowService.showUpcomingCard();

    expect(returnToExplorationSpy).toHaveBeenCalled();
  });

  it('should emit and return when questionSessionCompleted is true', () => {
    conversationFlowService.displayedCard = createCard('state1');
    conversationFlowService.questionSessionCompleted = true;

    spyOn(questionPlayerEngineService.onQuestionSessionCompleted, 'emit');
    spyOn(
      questionPlayerEngineService,
      'getQuestionPlayerStateData'
    ).and.returnValue({dummy: 'data'});

    conversationFlowService.showUpcomingCard();

    expect(
      questionPlayerEngineService.getQuestionPlayerStateData
    ).toHaveBeenCalled();
    expect(
      questionPlayerEngineService.onQuestionSessionCompleted.emit
    ).toHaveBeenCalledWith({dummy: 'data'});
  });

  it('should reset moveToExploration and load initial state', () => {
    conversationFlowService.displayedCard = createCard('State1');
    conversationFlowService.moveToExploration = true;

    spyOn(explorationModeService, 'setExplorationModeFromUrl');
    spyOn(explorationEngineService, 'loadInitialState');

    conversationFlowService.showUpcomingCard();

    expect(conversationFlowService.moveToExploration).toBeFalse();
    expect(explorationModeService.setExplorationModeFromUrl).toHaveBeenCalled();
    expect(explorationEngineService.loadInitialState).toHaveBeenCalled();
  });

  it('should go to revision card when isLearnAgainButton is true', () => {
    conversationFlowService.displayedCard = createCard('State1');

    spyOn(conversationFlowService, 'getNextStateCard').and.returnValue({
      getStateName: () => 'State1',
    });
    spyOn(conversationFlowService, 'isLearnAgainButton').and.returnValue(true);
    spyOn(
      playerTranscriptService,
      'findIndexOfLatestStateWithName'
    ).and.returnValue(2);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue({
      getStateName: () => 'State1',
    });
    spyOn(conversationFlowService.displayedCard, 'markAsNotCompleted');

    conversationFlowService.showUpcomingCard();

    expect(
      conversationFlowService.displayedCard.markAsNotCompleted
    ).toHaveBeenCalled();
    expect(playerPositionService.setDisplayedCardIndex).toHaveBeenCalledWith(2);
  });

  it('should throw error when next card is null', () => {
    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
      explorationEngineService
    );
    spyOn(explorationEngineService, 'recordNewCardAdded');
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(conversationFlowService, 'getNextStateCard').and.returnValue(null);
    spyOn(cardAnimationService, 'scheduleNextCardTransition');

    expect(() => {
      conversationFlowService.showPendingCard();
    }).toThrowError('Next card cannot be null when showing pending card.');
  });

  it('should call showPendingCard when no special condition matches', () => {
    conversationFlowService.displayedCard = {
      getStateName: () => 'State1',
      isCompleted: () => false,
    };

    spyOn(conversationFlowService, 'getNextStateCard').and.returnValue({
      getStateName: () => 'NextState',
    });
    spyOn(conceptCardManagerService, 'getConceptCard').and.returnValue(null);
    spyOn(conversationFlowService, 'isLearnAgainButton').and.returnValue(false);
    spyOn(conversationFlowService, 'getAnswerIsCorrect').and.returnValue(false);
    spyOn(conversationFlowService, 'setAnswerIsCorrect');
    spyOn(conversationFlowService, 'showPendingCard');

    conversationFlowService.showUpcomingCard();

    expect(conversationFlowService.setAnswerIsCorrect).toHaveBeenCalledWith(
      false
    );
    expect(conversationFlowService.showPendingCard).toHaveBeenCalled();
  });

  it('should test getters', () => {
    expect(conversationFlowService.onPlayerStateChange).toBeDefined();
    expect(conversationFlowService.onOppiaFeedbackAvailable).toBeDefined();
    expect(conversationFlowService.onShowProgressModal).toBeDefined();
  });

  it('should record leaving for refresher exploration if not in editor', () => {
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'StateName'
    );
  });

  it('should move forward by one card when index is valid', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(2);
    spyOn(playerPositionService, 'setDisplayedCardIndex').and.callFake(
      () => {}
    );
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'StateName'
    );
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(5);
    conversationFlowService.moveForwardByOneCard();

    expect(playerPositionService.getDisplayedCardIndex).toHaveBeenCalled();
  });

  it('should set and get hasInteractedAtLeastOnce correctly', () => {
    conversationFlowService.setHasInteractedAtLeastOnce(true);
    // Since there is no getter, we can indirectly check expected behavior,
    // but here we just test the method does not throw.
    expect().nothing();

    conversationFlowService.setHasInteractedAtLeastOnce(false);
    expect().nothing();
  });

  it('should set and get explorationActuallyStarted correctly', () => {
    conversationFlowService.setExplorationActuallyStarted(true);
    expect(conversationFlowService.getExplorationActuallyStarted()).toBeTrue();

    conversationFlowService.setExplorationActuallyStarted(false);
    expect(conversationFlowService.getExplorationActuallyStarted()).toBeFalse();
  });

  it('should set and get showProgressClearanceMessage correctly', () => {
    conversationFlowService.setShowProgressClearanceMessage(true);
    expect(
      conversationFlowService.getShowProgressClearanceMessage()
    ).toBeTrue();

    conversationFlowService.setShowProgressClearanceMessage(false);
    expect(
      conversationFlowService.getShowProgressClearanceMessage()
    ).toBeFalse();
  });

  it('should set and get answerIsCorrect correctly', () => {
    conversationFlowService.setAnswerIsCorrect(true);
    expect(conversationFlowService.getAnswerIsCorrect()).toBeTrue();

    conversationFlowService.setAnswerIsCorrect(false);
    expect(conversationFlowService.getAnswerIsCorrect()).toBeFalse();
  });

  it('should set and get answerIsBeingProcessed correctly', () => {
    conversationFlowService.setAnswerIsBeingProcessed(true);
    expect(conversationFlowService.getAnswerIsBeingProcessed()).toBeTrue();

    conversationFlowService.setAnswerIsBeingProcessed(false);
    expect(conversationFlowService.getAnswerIsBeingProcessed()).toBeFalse();
  });

  it('should set and get hasInteractedAtLeastOnce correctly', () => {
    conversationFlowService.setHasInteractedAtLeastOnce(true);
    expect(conversationFlowService.getHasInteractedAtLeastOnce()).toBeTrue();

    conversationFlowService.setHasInteractedAtLeastOnce(false);
    expect(conversationFlowService.getHasInteractedAtLeastOnce()).toBeFalse();
  });

  it('should set and get hasFullyLoaded correctly', () => {
    conversationFlowService.setHasFullyLoaded(true);
    expect(conversationFlowService.getHasFullyLoaded()).toBeTrue();

    conversationFlowService.setHasFullyLoaded(false);
    expect(conversationFlowService.getHasFullyLoaded()).toBeFalse();
  });

  it('should set and get answerIsCorrect correctly', () => {
    conversationFlowService.setAnswerIsCorrect(true);
    expect(conversationFlowService.getAnswerIsCorrect()).toBeTrue();

    conversationFlowService.setAnswerIsCorrect(false);
    expect(conversationFlowService.getAnswerIsCorrect()).toBeFalse();
  });

  it('should get solutionForState correctly', () => {
    conversationFlowService.solutionForState = null;
    expect(conversationFlowService.getSolutionForState()).toBeFalsy();
  });

  it('should set and get answerIsBeingProcessed correctly', () => {
    conversationFlowService.setAnswerIsBeingProcessed(true);
    expect(conversationFlowService.getAnswerIsBeingProcessed()).toBeTrue();

    conversationFlowService.setAnswerIsBeingProcessed(false);
    expect(conversationFlowService.getAnswerIsBeingProcessed()).toBeFalse();
  });

  it('should set and get hasInteractedAtLeastOnce correctly', () => {
    conversationFlowService.setHasInteractedAtLeastOnce(true);
    expect(conversationFlowService.getHasInteractedAtLeastOnce()).toBeTrue();

    conversationFlowService.setHasInteractedAtLeastOnce(false);
    expect(conversationFlowService.getHasInteractedAtLeastOnce()).toBeFalse();
  });

  it('should move backward by one card when index is valid', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(2);
    spyOn(playerPositionService, 'setDisplayedCardIndex').and.callFake(
      () => {}
    );
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'StateName'
    );
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(5);
    conversationFlowService.moveBackByOneCard();

    expect(playerPositionService.getDisplayedCardIndex).toHaveBeenCalled();
  });

  it('should skip checkpoint logic if index â‰¤ 0', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(null);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');

    conversationFlowService.navigateToDisplayedCard();

    expect(playerPositionService.onActiveCardChanged.emit).toHaveBeenCalled();
    expect(audioPlayerService.onAutoplayAudio.emit).toHaveBeenCalled();
    expect(autogeneratedAudioPlayerService.cancel).toHaveBeenCalled();
    expect(focusManagerService.setFocusIfOnDesktop).toHaveBeenCalled();
  });

  it('should skip when isIframed is true', () => {
    spyOn(urlService, 'isIframed').and.returnValue(true);
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(null);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');

    conversationFlowService.navigateToDisplayedCard();

    expect(playerPositionService.onActiveCardChanged.emit).toHaveBeenCalled();
    expect(audioPlayerService.onAutoplayAudio.emit).toHaveBeenCalled();
    expect(autogeneratedAudioPlayerService.cancel).toHaveBeenCalled();
    expect(focusManagerService.setFocusIfOnDesktop).toHaveBeenCalled();
  });

  it('should skip when editor preview mode is true', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      true
    );
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(null);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');

    conversationFlowService.navigateToDisplayedCard();

    expect(playerPositionService.onActiveCardChanged.emit).toHaveBeenCalled();
  });

  it('should skip when in question player mode', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      true
    );
    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(false);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(null);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');

    conversationFlowService.navigateToDisplayedCard();

    expect(playerPositionService.onActiveCardChanged.emit).toHaveBeenCalled();
  });

  it('should skip when in diagnostic test player mode', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      false
    );
    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(true);
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(null);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');

    conversationFlowService.navigateToDisplayedCard();

    expect(playerPositionService.onActiveCardChanged.emit).toHaveBeenCalled();
  });

  it('should return false when concept card is shown', () => {
    const conceptCard = new StateCard(
      null,
      null,
      null,
      new Interaction([], [], null, null, [], null, null),
      [],
      '',
      null
    );

    conversationFlowService.displayedCard = conceptCard;
    spyOn(explorationModeService, 'isInQuestionMode').and.returnValue(false);

    const result = conversationFlowService.isLearnAgainButton();
    expect(result).toBeFalse();
  });

  it('should return false when interaction id is missing', () => {
    const card = new StateCard(
      'State1',
      null,
      null,
      new Interaction([], [], null, null, [], null, null),
      [],
      '',
      null
    );

    conversationFlowService.displayedCard = card;

    const result = conversationFlowService.isLearnAgainButton();
    expect(result).toBeFalse();
  });

  it('should return false when interaction is linear', () => {
    const card = new StateCard(
      'State1',
      null,
      null,
      new Interaction([], [], null, null, [], 'Continue', null),
      [],
      '',
      null
    );

    conversationFlowService.displayedCard = card;

    const result = conversationFlowService.isLearnAgainButton();
    expect(result).toBeFalse();
  });

  it('should return true when all conditions met', () => {
    const card = new StateCard(
      'State1',
      null,
      null,
      new Interaction([], [], null, null, [], 'TextInput', null),
      [],
      '',
      null
    );

    conversationFlowService.displayedCard = card;
    conversationFlowService.pendingCardWasSeenBefore = true;
    spyOn(conversationFlowService, 'getAnswerIsCorrect').and.returnValue(false);

    const result = conversationFlowService.isLearnAgainButton();
    expect(result).toBeTrue();
  });

  it('should return false when answer is correct even if card seen before', () => {
    const card = new StateCard(
      'State1',
      null,
      null,
      new Interaction([], [], null, null, [], 'TextInput', null),
      [],
      '',
      null
    );

    conversationFlowService.displayedCard = card;
    conversationFlowService.pendingCardWasSeenBefore = true;
    spyOn(conversationFlowService, 'getAnswerIsCorrect').and.returnValue(true);

    const result = conversationFlowService.isLearnAgainButton();
    expect(result).toBeFalse();
  });

  it('should skip checkpoint logic when card is not checkpoint', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      false
    );
    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(false);
    spyOn(explorationEngineService, 'getState').and.returnValue({
      name: 'State1',
      cardIsCheckpoint: false,
    });
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(null);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');

    conversationFlowService.navigateToDisplayedCard();

    expect(playerPositionService.onActiveCardChanged.emit).toHaveBeenCalled();
  });

  it('should show upcoming card', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(displayedCard, 'getStateName').and.returnValue(null);
    conversationFlowService.displayedCard = displayedCard;
    spyOn(explorationModeService, 'isInQuestionMode').and.returnValues(
      false,
      true,
      true,
      true,
      true
    );
    spyOn(playerTranscriptService, 'isLastCard').and.returnValues(
      true,
      false,
      false,
      false,
      false
    );
    spyOn(conceptCardManagerService, 'returnToExplorationAfterConceptCard');
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');

    conversationFlowService.showUpcomingCard();

    conversationFlowService.questionSessionCompleted = true;
    spyOn(questionPlayerEngineService.onQuestionSessionCompleted, 'emit');
    spyOn(questionPlayerEngineService, 'getQuestionPlayerStateData');
    spyOn(urlService, 'getUrlParams').and.returnValue({
      topic_url_fragment: 'topicUrlFragment',
      classroom_url_fragment: 'classroomUrlFragment',
      story_url_fragment: 'storyUrlFragment',
      node_id: 'nodeId',
    });

    conversationFlowService.showUpcomingCard();

    conversationFlowService.questionSessionCompleted = false;
    conversationFlowService.moveToExploration = true;
    spyOn(explorationEngineService, 'loadInitialState');

    conversationFlowService.showUpcomingCard();

    conversationFlowService.moveToExploration = false;
    let stateCard = new StateCard(
      'stateName',
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      '',
      null
    );
    stateCard.markAsCompleted();
    conversationFlowService.displayedCard = stateCard;
    conversationFlowService.setNextStateCard(stateCard);
    conceptCardManagerService.setConceptCard(
      new ConceptCard(new SubtitledHtml('', ''), [], null)
    );
    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
      explorationEngineService
    );
    spyOn(explorationEngineService, 'recordNewCardAdded');
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(10);
    spyOn(
      conversationFlowService,
      'isSupplementalCardNonempty'
    ).and.returnValues(false, true);
    spyOn(playerTranscriptService, 'getCard');
    spyOn(cardAnimationService, 'canWindowShowTwoCards').and.returnValue(true);
    spyOn(playerPositionService, 'setDisplayedCardIndex');
    spyOn(cardAnimationService, 'animateToTwoCards');
    spyOn(playerPositionService, 'changeCurrentQuestion');
    spyOn(conversationFlowService, 'showPendingCard');
    spyOn(urlService, 'getQueryFieldValuesAsList').and.returnValue([]);
    spyOn(
      explorationEngineService,
      'getAuthorRecommendedExpIdsByStateName'
    ).and.returnValue([]);
    spyOn(explorationModeService, 'isInStoryChapterMode').and.returnValue(true);
    spyOn(userService, 'setReturnUrl');

    conversationFlowService.isLoggedIn = false;

    conversationFlowService.showUpcomingCard();

    conceptCardManagerService.setConceptCard(null);
    conversationFlowService.answerIsCorrect = true;

    conversationFlowService.showUpcomingCard();
  });

  it('should submit answer and reset current answer state', fakeAsync(() => {
    spyOn(displayedCard, 'updateCurrentAnswer');
    conversationFlowService.displayedCard = displayedCard;
    conversationFlowService.answerIsBeingProcessed = true;

    conversationFlowService.submitAnswer('', null);

    expect(displayedCard.updateCurrentAnswer).toHaveBeenCalledOnceWith(null);
    conversationFlowService.answerIsBeingProcessed = false;
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(
      playerPositionService,
      'isCurrentCardAtEndOfTranscript'
    ).and.returnValue(true);
    let explorationModeSpy = spyOn(
      explorationModeService,
      'isPresentingIsolatedQuestions'
    );
    explorationModeSpy.and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(fatigueDetectionService, 'recordSubmissionTimestamp');
    spyOn(fatigueDetectionService, 'isSubmittingTooFast').and.returnValues(
      true,
      false
    );
    spyOn(fatigueDetectionService, 'displayTakeBreakMessage');
    let lastCardInteraction = Interaction.createFromBackendDict({
      id: 'TextInput',
      answer_groups: [],
      default_outcome: {
        missing_prerequisite_skill_id: null,
        refresher_exploration_id: null,
        labelled_as_correct: false,
        feedback: {
          content_id: 'default_outcome',
          html: 'Wrong answer',
        },
        param_changes: [],
        dest_if_really_stuck: null,
        dest: 'Start',
      },
      confirmed_unclassified_answers: [],
      customization_args: {
        rows: {
          value: true,
        },
        placeholder: {
          value: 1,
        },
      },
      hints: [],
      solution: null,
    });
    let lastCard = StateCard.createNewCard(
      'Card 1',
      'Content html',
      'Interaction text',
      lastCardInteraction,
      null,
      'content_id'
    );
    spyOn(playerTranscriptService, 'getLastCard').and.returnValue(lastCard);
    spyOn(conversationFlowService.onOppiaFeedbackAvailable, 'emit');
    spyOn(conversationFlowService, 'showPendingCard');
    conversationFlowService.submitAnswer('', null);

    spyOn(explorationModeService, 'isInQuestionMode').and.returnValues(
      false,
      false,
      false,
      true
    );
    spyOn(learnerAnswerInfoService, 'initLearnerAnswerInfoService');
    spyOn(explorationEngineService, 'getState');
    spyOn(numberAttemptsService, 'submitAttempt');
    spyOn(playerTranscriptService, 'addNewInput');
    spyOn(
      learnerAnswerInfoService,
      'getCanAskLearnerForAnswerInfo'
    ).and.returnValues(true, false);
    spyOn(playerTranscriptService, 'addNewResponse');
    spyOn(learnerAnswerInfoService, 'getSolicitAnswerDetailsQuestion');
    spyOn(playerPositionService.onHelpCardAvailable, 'emit');
    spyOn(playerPositionService, 'setDisplayedCardIndex');

    conversationFlowService.submitAnswer('', null);
    tick(200);

    spyOn(playerPositionService, 'recordAnswerSubmission');
    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
      explorationEngineService
    );

    let callback = (
      answer: string,
      interactionRulesService: InteractionRulesService,
      successCallback: (
        nextCard: StateCard,
        refreshInteraction: boolean,
        feedbackHtml: string,
        refresherExplorationId: string,
        missingPrerequisiteSkillId: string,
        remainOnCurrentCard: boolean,
        taggedSkillMisconceptionId: string,
        wasOldStateInitial: boolean,
        isFirstHit: boolean,
        isFinalQuestion: boolean,
        nextCardIfReallyStuck: StateCard | null,
        focusLabel: string
      ) => void
    ) => {
      let stateCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'EndExploration', null),
        [],
        '',
        null
      );
      successCallback(
        stateCard,
        true,
        'feedback',
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        true,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        '',
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        true,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        'feedback',
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        '',
        'refresherId',
        '',
        false,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      successCallback(
        stateCard,
        true,
        'feedback',
        '',
        'skill_id',
        true,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      explorationModeSpy.and.returnValue(true);
      conversationFlowService.displayedCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'TextInput', null),
        [],
        '',
        null
      );
      spyOn(
        explorationModeService,
        'isInDiagnosticTestPlayerMode'
      ).and.returnValue(true);
      successCallback(
        stateCard,
        true,
        'feedback',
        '',
        'skill_id',
        true,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      conversationFlowService.displayedCard = new StateCard(
        null,
        null,
        null,
        new Interaction([], [], null, null, [], 'ImageClickInput', null),
        [],
        '',
        null
      );
      explorationModeSpy.and.returnValue(false);
      successCallback(
        stateCard,
        true,
        'feedback',
        'refresherId',
        'skill_id',
        true,
        '',
        true,
        false,
        false,
        null,
        ''
      );
      return false;
    };
    spyOn(
      answerClassificationService,
      'isAnswerOnlyMisspelled'
    ).and.returnValue(true);
    spyOn(explorationEngineService, 'submitAnswer').and.callFake(callback);
    spyOn(playerPositionService, 'getCurrentStateName').and.returnValue(
      'oldState'
    );
    spyOn(statsReportingService, 'recordStateTransition');
    spyOn(learnerParamsService, 'getAllParams');
    spyOn(statsReportingService, 'recordStateCompleted');
    spyOn(statsReportingService, 'recordExplorationActuallyStarted');
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      true
    );
    spyOn(conversationFlowService, 'showUpcomingCard');
    spyOn(fatigueDetectionService, 'reset');
    spyOn(numberAttemptsService, 'reset');
    spyOn(questionPlayerEngineService, 'recordAnswerSubmitted');
    spyOn(questionPlayerEngineService, 'getCurrentQuestion');
    spyOn(playerTranscriptService, 'updateLatestInteractionHtml');
    spyOn(
      conceptCardBackendApiService,
      'loadConceptCardsAsync'
    ).and.returnValue(
      Promise.resolve([new ConceptCard(new SubtitledHtml('', ''), [], null)])
    );

    spyOn(
      explorationSummaryBackendApiService,
      'loadPublicExplorationSummariesAsync'
    ).and.returnValue(
      Promise.resolve({
        summaries: [{} as ExplorationSummaryDict],
      })
    );
    spyOn(
      refresherExplorationConfirmationModalService,
      'displayRedirectConfirmationModal'
    ).and.callFake((id, callb) => {
      callb();
    });
    spyOn(statsReportingService, 'recordLeaveForRefresherExp');
    spyOn(playerTranscriptService, 'hasEncounteredStateBefore').and.returnValue(
      true
    );
    spyOn(explorationEngineService, 'recordNewCardAdded');

    conversationFlowService.explorationActuallyStarted = false;

    conversationFlowService.submitAnswer('', null);
    tick(2000);
  }));

  it('should record checkpoint when card is checkpoint and not yet visited', fakeAsync(() => {
    const currentStateName = 'State1';
    const version = 1;

    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      false
    );
    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(false);
    spyOn(explorationEngineService, 'getState').and.returnValue({
      name: currentStateName,
      cardIsCheckpoint: true,
    });
    spyOn(
      checkpointProgressService,
      'checkIfCheckpointIsVisited'
    ).and.returnValue(false);
    spyOn(
      playerTranscriptService,
      'getPrevSessionStatesProgress'
    ).and.returnValue([]);
    spyOn(progressUrlService, 'getUniqueProgressUrlId').and.returnValue(
      'uuid-123'
    );

    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve({version}));

    const recordSpy = spyOn(
      editableExplorationBackendApiService,
      'recordMostRecentlyReachedCheckpointAsync'
    ).and.stub();

    conversationFlowService.navigateToDisplayedCard();
    flushMicrotasks();
    tick();

    expect(recordSpy).toHaveBeenCalledWith(
      'expId',
      version,
      currentStateName,
      conversationFlowService.isLoggedIn,
      'uuid-123'
    );
  }));

  it('should focus next focus label when last card', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(
      'next-focus'
    );
    spyOn(explorationEngineService, 'getState').and.returnValue({
      name: 'State1',
      cardIsCheckpoint: false,
    });
    spyOn(playerTranscriptService, 'getLastStateName').and.returnValue(
      'State1'
    );
    const focusSpy = spyOn(
      focusManagerService,
      'setFocusIfOnDesktop'
    ).and.stub();

    conversationFlowService.navigateToDisplayedCard();

    expect(focusSpy).toHaveBeenCalledWith('next-focus');
  });

  it('should initialize directive components and set focus, scroll and emit', fakeAsync(() => {
    const card = createCard('TextInput');
    spyOn(playerPositionService, 'setDisplayedCardIndex').and.callFake(
      () => {}
    );
    spyOn(playerPositionService.onNewCardOpened, 'emit').and.callFake(() => {});
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    const iframeSpy = spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue(
      explorationEngineService
    );
    spyOn(explorationEngineService, 'getLanguageCode').and.returnValue('en');
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      false
    );
    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(false);
    spyOn(focusManagerService, 'setFocusIfOnDesktop').and.callFake(() => {});
    spyOn(loaderService, 'hideLoadingScreen').and.callFake(() => {});
    spyOn(i18nLanguageCodeService, 'setI18nLanguageCode').and.callFake(
      () => {}
    );
    spyOn(cardAnimationService, 'adjustPageHeight');
    spyOn(windowRef.nativeWindow, 'scrollTo').and.callFake(() => {});

    conversationFlowService.initializeDirectiveComponents(card, 'focus-label');

    tick();
    expect(focusManagerService.setFocusIfOnDesktop).toHaveBeenCalledWith(
      'focus-label'
    );

    iframeSpy.and.returnValue(true);
    conversationFlowService.initializeDirectiveComponents(card, 'focus-label');

    tick();
    expect(focusManagerService.setFocusIfOnDesktop).toHaveBeenCalledWith(
      'focus-label'
    );
  }));

  it('should set i18nLanguageCode to URL lang if iframe and lang is valid', fakeAsync(() => {
    const card = createCard('TextInput');
    conversationFlowService.displayedCard = card;
    spyOn(playerPositionService, 'setDisplayedCardIndex').and.callFake(
      () => {}
    );
    spyOn(urlService, 'isIframed').and.returnValue(true);
    spyOn(urlService, 'getUrlParams').and.returnValue({lang: 'es'});
    spyOn(i18nLanguageCodeService, 'setI18nLanguageCode');

    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue({
      getLanguageCode: () => 'en',
      recordNewCardAdded: () => {},
    });

    conversationFlowService.initializeDirectiveComponents(card, 'focus-label');
    tick(1000);

    expect(i18nLanguageCodeService.setI18nLanguageCode).toHaveBeenCalledWith(
      'es'
    );
  }));

  it('should set i18nLanguageCode to en if iframe and lang is missing or unsupported', fakeAsync(() => {
    const card = createCard('TextInput');
    conversationFlowService.displayedCard = card;
    spyOn(playerPositionService, 'setDisplayedCardIndex').and.callFake(
      () => {}
    );
    spyOn(urlService, 'isIframed').and.returnValue(true);
    spyOn(urlService, 'getUrlParams').and.returnValue({lang: 'xx'}); // Unsupported.
    spyOn(i18nLanguageCodeService, 'setI18nLanguageCode');

    spyOn(currentEngineService, 'getCurrentEngineService').and.returnValue({
      getLanguageCode: () => 'en',
      recordNewCardAdded: () => {},
    });

    conversationFlowService.initializeDirectiveComponents(card, 'focus-label');
    tick(1000);

    expect(i18nLanguageCodeService.setI18nLanguageCode).toHaveBeenCalledWith(
      'en'
    );
  }));

  it('should throw when currentState.name is null', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      false
    );
    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(false);
    spyOn(explorationEngineService, 'getState').and.returnValue({
      name: null,
      cardIsCheckpoint: true,
    });
    spyOn(
      playerTranscriptService,
      'getPrevSessionStatesProgress'
    ).and.returnValue([]);

    expect(() => {
      conversationFlowService.navigateToDisplayedCard();
    }).toThrowError(
      'Current state name cannot be null when navigating to displayed card.'
    );
  });

  it('should do full happy path and emit when navigateToDisplayedCard is called', fakeAsync(() => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);
    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );
    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      false
    );
    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(false);
    spyOn(explorationEngineService, 'getState').and.returnValue({
      name: 'State1',
      cardIsCheckpoint: true,
    });
    spyOn(
      playerTranscriptService,
      'getPrevSessionStatesProgress'
    ).and.returnValue([]);
    spyOn(
      checkpointProgressService,
      'checkIfCheckpointIsVisited'
    ).and.returnValue(false);
    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve({version: 2}));
    spyOn(
      editableExplorationBackendApiService,
      'recordMostRecentlyReachedCheckpointAsync'
    );
    spyOn(checkpointProgressService, 'setMostRecentlyReachedCheckpoint');
    spyOn(checkpointProgressService, 'setVisitedCheckpointStateNames');
    spyOn(playerPositionService.onActiveCardChanged, 'emit');
    spyOn(audioPlayerService.onAutoplayAudio, 'emit');
    spyOn(autogeneratedAudioPlayerService, 'cancel');
    spyOn(conversationFlowService, 'getNextFocusLabel').and.returnValue(
      'focusLabel'
    );
    spyOn(playerTranscriptService, 'isLastCard').and.returnValue(true);
    spyOn(focusManagerService, 'setFocusIfOnDesktop');

    conversationFlowService.navigateToDisplayedCard();
    tick();

    expect(
      checkpointProgressService.setMostRecentlyReachedCheckpoint
    ).toHaveBeenCalledWith('State1');
    expect(
      editableExplorationBackendApiService.recordMostRecentlyReachedCheckpointAsync
    ).toHaveBeenCalled();
    expect(playerPositionService.onActiveCardChanged.emit).toHaveBeenCalled();
    expect(audioPlayerService.onAutoplayAudio.emit).toHaveBeenCalled();
    expect(autogeneratedAudioPlayerService.cancel).toHaveBeenCalled();
    expect(focusManagerService.setFocusIfOnDesktop).toHaveBeenCalledWith(
      'focusLabel'
    );
  }));

  it('should throw an error if version is null when recording checkpoint progress', done => {
    const mockResponse = {version: null};

    spyOn(
      readOnlyExplorationBackendApiService,
      'loadLatestExplorationAsync'
    ).and.returnValue(Promise.resolve(mockResponse));

    spyOn(explorationEngineService, 'getState').and.returnValue({
      name: 'test_state',
      cardIsCheckpoint: true,
    });

    spyOn(
      playerTranscriptService,
      'getPrevSessionStatesProgress'
    ).and.returnValue([]);

    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(1);

    spyOn(explorationModeService, 'isInQuestionPlayerMode').and.returnValue(
      false
    );

    spyOn(
      explorationModeService,
      'isInDiagnosticTestPlayerMode'
    ).and.returnValue(false);

    spyOn(urlService, 'isIframed').and.returnValue(false);
    spyOn(pageContextService, 'isInExplorationEditorPage').and.returnValue(
      false
    );

    spyOn(
      editableExplorationBackendApiService,
      'recordMostRecentlyReachedCheckpointAsync'
    );

    const originalConsoleError = console.error;
    console.error = () => {};

    conversationFlowService.navigateToDisplayedCard();

    setTimeout(() => {
      try {
        expect(
          editableExplorationBackendApiService.recordMostRecentlyReachedCheckpointAsync
        ).not.toHaveBeenCalled();

        done();
      } catch (e) {
        done.fail(e);
      } finally {
        console.error = originalConsoleError;
      }
    }, 0);
  });

  it('should throw error when moving forward beyond last card', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(4);
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(5);

    // Moving to index 5 (equal to num cards) â†’ out of bounds.
    expect(() => {
      conversationFlowService.moveForwardByOneCard();
    }).toThrowError('Target card index out of bounds.');
  });

  it('should throw error when moving backward before first card', () => {
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(playerTranscriptService, 'getNumCards').and.returnValue(5);

    // Moving to index -1 â†’ out of bounds.
    expect(() => {
      conversationFlowService.moveBackByOneCard();
    }).toThrowError('Target card index out of bounds.');
  });

  it('should return correct value for isRefresherExploration', () => {
    conversationFlowService.isRefresherExploration = true;
    expect(conversationFlowService.getIsRefresherExploration()).toBeTrue();

    conversationFlowService.isRefresherExploration = false;
    expect(conversationFlowService.getIsRefresherExploration()).toBeFalse();
  });

  it('should return correct parent exploration IDs', () => {
    const parentIds = ['exp1', 'exp2'];
    conversationFlowService.parentExplorationIds = parentIds;

    expect(conversationFlowService.getParentExplorationIds()).toEqual(
      parentIds
    );
  });

  it('should set and get nextCardIfStuck', () => {
    const mockCard = createCard('TextInput');
    conversationFlowService.setNextCardIfStuck(mockCard);
    expect(conversationFlowService.getNextCardIfStuck()).toBe(mockCard);
  });

  it('should set and get solution for state', () => {
    const mockSolution = {
      correctAnswer: true,
      explanationHtml: 'Html',
      answerIsExclusive: true,
      explanationContentId: 'content_id',
    } as Solution;

    conversationFlowService.setSolutionForState(mockSolution);
    expect(conversationFlowService.getSolutionForState()).toBe(mockSolution);
  });

  it('should defer stuck check when isDelayed is true', fakeAsync(() => {
    const mockCallback = jasmine.createSpy('onShowContinueToReviseButton');

    spyOn(
      playerTranscriptService,
      'getNumberOfIncorrectSubmissions'
    ).and.returnValue(
      ExplorationPlayerConstants.MAX_INCORRECT_ANSWERS_BEFORE_RELEASING_SOLUTION
    );
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);
    spyOn(playerTranscriptService, 'getCard').and.returnValue(
      createCard('TextInput')
    );
    spyOn(hintsAndSolutionManagerService, 'releaseSolution');

    const mockSolution = {
      correctAnswer: true,
      explanationHtml: 'Html',
      answerIsExclusive: true,
      explanationContentId: 'content_id',
    } as Solution;
    conversationFlowService.setSolutionForState(mockSolution);
    conversationFlowService.triggerIfLearnerStuckAction(true, mockCallback);
    tick(
      ExplorationPlayerConstants.WAIT_BEFORE_RESPONSE_FOR_STUCK_LEARNER_MSEC
    );

    expect(hintsAndSolutionManagerService.releaseSolution).toHaveBeenCalled();
  }));

  it('should defer stuck check when isDelayed is false', fakeAsync(() => {
    conversationFlowService.responseTimeout = 100;
    const mockCallback = jasmine.createSpy('onShowContinueToReviseButton');
    spyOn(playerPositionService, 'getDisplayedCardIndex').and.returnValue(0);

    const nextCardIfStuck = new StateCard(
      'StuckCard',
      null,
      null,
      new Interaction([], [], null, null, [], 'EndExploration', null),
      [],
      '',
      null
    );

    let displayedCard = new StateCard(
      'CurrentCard',
      null,
      null,
      new Interaction([], [], null, null, [], '', null),
      [],
      '',
      null
    );

    spyOn(playerTranscriptService, 'getCard').and.returnValue(displayedCard);
    conversationFlowService.nextCardIfStuck = nextCardIfStuck;
    conversationFlowService.triggerIfLearnerStuckAction(false, mockCallback);
  }));

  it('should set and get next state card', () => {
    const nextCard = new StateCard(
      'NextCard',
      null,
      null,
      new Interaction([], [], null, null, [], 'TextInput', null),
      [],
      '',
      null
    );

    conversationFlowService.setNextStateCard(nextCard);

    expect(conversationFlowService.getNextStateCard()).toBe(nextCard);
  });
});
