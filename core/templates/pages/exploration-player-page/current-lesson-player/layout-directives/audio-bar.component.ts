// Copyright 2021 The Oppia Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Component for a set of audio controls for a specific
 * audio translation in the learner view.
 */

import {
  Component,
  ViewChild,
  ElementRef,
  ChangeDetectorRef,
} from '@angular/core';
import {Voiceover} from 'domain/exploration/voiceover.model';
import {Subscription} from 'rxjs';
import {AssetsBackendApiService} from 'services/assets-backend-api.service';
import {AudioBarStatusService} from 'services/audio-bar-status.service';
import {AudioPlayerService} from 'services/audio-player.service';
import {PageContextService} from 'services/page-context.service';
import {SiteAnalyticsService} from 'services/site-analytics.service';
import {AudioPreloaderService} from '../../services/audio-preloader.service';
import {PlayerPositionService} from '../../services/player-position.service';
import {I18nLanguageCodeService} from 'services/i18n-language-code.service';
import {EntityVoiceoversService} from 'services/entity-voiceovers.services';
import {VoiceoverPlayerService} from '../../services/voiceover-player.service';
import {LanguageAccentToDescription} from 'domain/voiceover/voiceover-backend-api.service';
import {LocalStorageService} from 'services/local-storage.service';
import {StateEditorService} from 'components/state-editor/state-editor-properties-services/state-editor.service';

@Component({
  selector: 'oppia-audio-bar',
  templateUrl: './audio-bar.component.html',
})
export class AudioBarComponent {
  @ViewChild('audioControls', {static: false}) audioControlsRef!: ElementRef;
  lastScrollTop: number = 0;
  isPaused: boolean = true;
  directiveSubscriptions: Subscription = new Subscription();
  audioBarIsExpanded: boolean = false;
  progressBarIsShown: boolean = false;
  audioLoadingIndicatorIsShown: boolean = false;
  explorationPlayerModeIsActive: boolean;
  languageAccentCodesToDescriptions!: LanguageAccentToDescription;
  languageAccentDecriptions: string[] = [];
  selectedLanguageAccentDescription!: string;
  voiceoverToBePlayed!: Voiceover | undefined;
  currentVoiceoverTime: number = 0;
  totalVoiceoverDurationSecs: number = 0;

  constructor(
    private assetsBackendApiService: AssetsBackendApiService,
    private audioBarStatusService: AudioBarStatusService,
    private audioPlayerService: AudioPlayerService,
    private audioPreloaderService: AudioPreloaderService,
    private pageContextService: PageContextService,
    private playerPositionService: PlayerPositionService,
    private I18nLanguageCodeService: I18nLanguageCodeService,
    private siteAnalyticsService: SiteAnalyticsService,
    private entityVoiceoversService: EntityVoiceoversService,
    private voiceoverPlayerService: VoiceoverPlayerService,
    private localStorageService: LocalStorageService,
    private stateEditorService: StateEditorService,
    private cdRef: ChangeDetectorRef
  ) {
    this.explorationPlayerModeIsActive =
      this.pageContextService.isInExplorationPlayerPage();
  }

  ngOnInit(): void {
    this.directiveSubscriptions.add(
      this.voiceoverPlayerService.onTranslationLanguageChanged.subscribe(() => {
        this.audioPlayerService.stop();
        this.audioPlayerService.clear();
        this.voiceoverToBePlayed = undefined;
        this.setProgress({value: 0});
        this.updateDisplayableLanguageAccentDescription();
      })
    );

    this.directiveSubscriptions.add(
      this.voiceoverPlayerService.onActiveVoiceoverChanged.subscribe(() => {
        this.voiceoverToBePlayed =
          this.voiceoverPlayerService.getActiveVoiceover() as Voiceover;
      })
    );

    this.directiveSubscriptions.add(
      this.audioPlayerService.onAutoplayAudio.subscribe(() => {
        if (this.audioBarIsExpanded) {
          this.audioPlayerService.stop();
          // We use a timeout to allow for any previous audio to have
          // their 'onend' callback called. This is primarily used to
          // address delays with autogenerated audio callbacks.
          setTimeout(() => {
            if (!this.isPaused) {
              this.onPlayButtonClicked();
            }
          }, 100);
        }
      })
    );
    this.audioBarIsExpanded = false;
    this.progressBarIsShown = false;
    this.audioLoadingIndicatorIsShown = false;
    this.audioPreloaderService.setAudioLoadedCallback(
      this.onFinishedLoadingAudio.bind(this)
    );

    this.languageAccentDecriptions =
      this.voiceoverPlayerService.getLanguageAccentDescriptions();
  }

  ngOnDestroy(): void {
    this.directiveSubscriptions.unsubscribe();
  }

  ngAfterContentChecked(): void {
    if (
      this.audioPlayerService.isTrackLoaded() &&
      this.audioPlayerService.isPlaying()
    ) {
      this.currentVoiceoverTime =
        this.audioPlayerService.getCurrentTimeInSecs();
      this.totalVoiceoverDurationSecs = Math.floor(
        this.audioPlayerService.getAudioDuration()
      );
    }
    if (!this.audioPlayerService.isTrackLoaded()) {
      this.currentVoiceoverTime = 0;
    }
  }

  setProgress(val: {value: number}): void {
    this.audioPlayerService.setCurrentTime(val.value);
  }

  isAudioBarAvailable(): boolean {
    return this.languageAccentDecriptions.length > 0;
  }

  isLanguageRTL(): boolean {
    return this.I18nLanguageCodeService.isCurrentLanguageRTL();
  }

  focusOnAudioControls(): void {
    this.audioControlsRef?.nativeElement.focus();
  }

  expandAudioBar(): void {
    this.audioBarIsExpanded = true;
    this.audioBarStatusService.markAudioBarExpanded();
    this.cdRef.detectChanges();
    this.focusOnAudioControls();
  }

  collapseAudioBar(): void {
    this.audioBarStatusService.markAudioBarCollapsed();
    this.audioBarIsExpanded = false;
    this.audioPlayerService.stop();
    this.audioPlayerService.clear();
  }

  isAudioPlaying(): boolean {
    return this.audioPlayerService.isPlaying();
  }

  isAudioAvailableInCurrentLanguageAccent(): boolean {
    return this.voiceoverToBePlayed !== undefined;
  }

  doesCurrentAudioTranslationNeedUpdate(): boolean {
    return this.voiceoverToBePlayed?.needsUpdate ?? false;
  }

  onBackwardButtonClicked(): void {
    this.audioPlayerService.rewind(5);
  }

  onForwardButtonClicked(): void {
    this.audioPlayerService.forward(5);
  }

  updateDisplayableLanguageAccentDescription(): void {
    this.languageAccentDecriptions =
      this.voiceoverPlayerService.getLanguageAccentDescriptions();

    if (this.languageAccentDecriptions.length > 0) {
      this.selectedLanguageAccentDescription =
        this.languageAccentDecriptions[0];
      this.updateSelectedLanguageAccent();
    }
  }

  updateSelectedLanguageAccent(): void {
    this.audioPlayerService.stop();
    this.audioPlayerService.clear();
    this.setProgress({value: 0});
    let languageAccentCode =
      this.voiceoverPlayerService.languageAccentDescriptionsToCodes[
        this.selectedLanguageAccentDescription as string
      ];
    this.entityVoiceoversService.setActiveLanguageAccentCode(
      languageAccentCode
    );
    let entityVoiceover =
      this.entityVoiceoversService.getActiveEntityVoiceovers();

    let contentId = this.voiceoverPlayerService.activeContentId;

    let manualVoiceover = entityVoiceover.getManualVoiceover(
      contentId
    ) as Voiceover;
    let automaticVoiceover = entityVoiceover.getAutomaticVoiceover(
      contentId
    ) as Voiceover;

    if (manualVoiceover && manualVoiceover.needsUpdate === false) {
      this.voiceoverToBePlayed = manualVoiceover;
    } else if (automaticVoiceover && automaticVoiceover.needsUpdate === false) {
      this.voiceoverToBePlayed = automaticVoiceover;
    }

    this.audioPreloaderService.contentIdsToVoiceovers =
      this.entityVoiceoversService.getAllContentIdsToVoiceovers();
    this.audioPreloaderService.restartAudioPreloader(
      this.getCurrentStateName()
    );
  }

  getCurrentStateName(): string {
    if (this.pageContextService.isInExplorationPlayerPage()) {
      return this.playerPositionService.getCurrentStateName();
    }
    return this.stateEditorService.getActiveStateName() as string;
  }

  onPlayButtonClicked(): void {
    this.isPaused = !this.isPaused;
    this.progressBarIsShown = true;

    if (this.voiceoverToBePlayed) {
      this.playPauseUploadedAudioTranslation();
    }

    this.siteAnalyticsService.registerStartAudioPlayedEvent(
      this.pageContextService.getExplorationId(),
      this.playerPositionService.getDisplayedCardIndex()
    );
  }

  isCached(audioTranslation: Voiceover): boolean {
    return this.assetsBackendApiService.isCached(audioTranslation.filename);
  }

  playPauseUploadedAudioTranslation(): void {
    if (!this.audioPlayerService.isPlaying()) {
      if (this.audioPlayerService.isTrackLoaded()) {
        this.audioPlayerService.play();
      } else {
        this.loadAndPlayAudioTranslation();
      }
    } else {
      this.audioPlayerService.pause();
    }
  }

  playCachedAudioTranslation(audioFilename: string): void {
    this.audioPlayerService.loadAsync(audioFilename).then(() => {
      this.audioLoadingIndicatorIsShown = false;
      this.audioPlayerService.play();
    });
  }

  /**
   * Called when an audio file finishes loading.
   * @param {string} audioFilename - Filename of the audio file that
   *                                 finished loading.
   */
  onFinishedLoadingAudio(audioFilename: string): void {
    let mostRecentlyRequestedAudioFilename =
      this.audioPreloaderService.getMostRecentlyRequestedAudioFilename();
    if (
      this.audioLoadingIndicatorIsShown &&
      audioFilename === mostRecentlyRequestedAudioFilename
    ) {
      this.playCachedAudioTranslation(audioFilename);
    }
  }

  loadAndPlayAudioTranslation(): void {
    this.audioLoadingIndicatorIsShown = true;
    let audioTranslation = this.voiceoverToBePlayed as Voiceover;

    if (audioTranslation) {
      this.audioPreloaderService.setMostRecentlyRequestedAudioFilename(
        audioTranslation.filename
      );
      if (this.isCached(audioTranslation)) {
        this.playCachedAudioTranslation(audioTranslation.filename);
      } else if (
        !this.audioPreloaderService.isLoadingAudioFile(
          audioTranslation.filename
        )
      ) {
        let contentIdsToVoiceovers =
          this.entityVoiceoversService.getAllContentIdsToVoiceovers();
        this.audioPreloaderService.contentIdsToVoiceovers =
          contentIdsToVoiceovers;
        this.audioPreloaderService.restartAudioPreloader(
          this.playerPositionService.getCurrentStateName()
        );
      }
    }
  }
}
