# coding: utf-8
#
# Copyright 2025 The Oppia Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Models for managing Goolge cloud task queue runs."""

from __future__ import annotations

import enum
import uuid

from core import feconf, utils
from core.platform import models

from typing import Dict, Final, Type

MYPY = False
if MYPY:  # pragma: no cover
    from mypy_imports import base_models, datastore_services

(base_models,) = models.Registry.import_models([models.Names.BASE_MODEL])

datastore_services = models.Registry.import_datastore_services()

_MAX_ID_GENERATION_ATTEMPTS: Final = 5


def _get_new_model_id(model_class: Type[base_models.BaseModel]) -> str:
    """Generates an ID for a new CloudTaskRunModel.

    Args:
        model_class: CloudTaskRunModel. The class for which the ID is
            being generated.

    Returns:
        str. The new ID.

    Raises:
        RuntimeError. The function failed to generate a new ID.
    """
    for _ in range(_MAX_ID_GENERATION_ATTEMPTS):
        new_id = utils.convert_to_hash(uuid.uuid4().hex, 22)
        if model_class.get(new_id, strict=False) is None:
            return new_id
    raise RuntimeError(
        'Failed to generate a unique ID after %d attempts'
        % (_MAX_ID_GENERATION_ATTEMPTS)
    )


class CloudTaskState(enum.Enum):
    """Constants from an enum, this represents the state of a cloud task run."""

    # The job is successfully completed.
    SUCCEEDED = 'SUCCEEDED'
    # The job has permanently failed and will not be retried.
    PERMANENTLY_FAILED = 'PERMANENTLY_FAILED'
    # The job has failed but is awaiting retry.
    FAILED_AND_AWAITING_RETRY = 'FAILED_AND_AWAITING_RETRY'
    # The job is currently running.
    RUNNING = 'RUNNING'
    # The job is pending and has not yet started to run.
    PENDING = 'PENDING'


class CloudTaskRunModel(base_models.BaseModel):
    """Represents the execution of an individual cloud task run.

    The IDs of CloudTaskRunModel are used by CloudTaskRunModel, and
    generated by using the urlsafe base64 encoding of a uuid() value:
    ^[A-Za-z0-9-_]{22}$.
    """

    # The cloud_task_name is the full name of the cloud task, which includes
    # the project ID, location ID, queue ID, and task ID.
    # The pattern of the cloud task name is:
    # projects/{project_id}/locations/{location_id}/queues/{queue_id}/tasks/
    # {task_id}
    cloud_task_name = datastore_services.StringProperty(
        required=False, indexed=True
    )

    # The task_id is the ID of the cloud task run. Added as a seperate
    # property to allow for easier querying of tasks by their ID.
    task_id = datastore_services.StringProperty(
        required=True, indexed=True, default=None
    )

    # The queue_id is the ID of the queue that the cloud task belongs to. Added
    # as a separate property to allow for easier querying of tasks by their
    # queue ID.
    queue_id = datastore_services.StringProperty(
        required=True, indexed=True, default=None
    )

    # The state of the job at the time the model was last updated.
    latest_job_state = datastore_services.StringProperty(
        required=True,
        indexed=True,
        choices=[
            CloudTaskState.RUNNING.value,
            CloudTaskState.SUCCEEDED.value,
            CloudTaskState.PERMANENTLY_FAILED.value,
            CloudTaskState.FAILED_AND_AWAITING_RETRY.value,
            CloudTaskState.PENDING.value,
        ],
    )

    # The function_id corresponding to the function that is being run
    # by the cloud task. This is used to identify which function is being
    # executed by the cloud task, and is used to determine the function name
    # that is being executed in the deferred job handler.
    function_id = datastore_services.StringProperty(
        required=True,
        indexed=True,
        choices=list(
            feconf.FUNCTION_ID_TO_FUNCTION_NAME_FOR_DEFERRED_JOBS.values()
        ),
    )

    # The property stores exception messages for failed runs of the cloud task.
    exception_messages_for_failed_runs = datastore_services.JsonProperty(
        required=False, indexed=False, default=[]
    )

    # The property tracks the number of retry attempts for the cloud task run.
    current_retry_attempt = datastore_services.IntegerProperty(
        required=True, indexed=True, default=0
    )

    @staticmethod
    def get_deletion_policy() -> base_models.DELETION_POLICY:
        """Model doesn't contain any data directly corresponding to a user.

        This model is marked as deleted after a period of time after its
        creation. See MODEL_CLASSES_TO_MARK_AS_DELETED and
        mark_outdated_models_as_deleted() in cron_services.py.

        This model is being deleted because it has no significance without these
        other models, but note that this is being done only for data consistency
        and is not a requirement of the wipeout process.
        """
        return base_models.DELETION_POLICY.NOT_APPLICABLE

    @staticmethod
    def get_model_association_to_user() -> (
        base_models.MODEL_ASSOCIATION_TO_USER
    ):
        """Model doesn't contain user data."""
        return base_models.MODEL_ASSOCIATION_TO_USER.NOT_CORRESPONDING_TO_USER

    @classmethod
    def get_export_policy(cls) -> Dict[str, base_models.EXPORT_POLICY]:
        """Model doesn't contain any data directly corresponding to a user."""
        return dict(
            super(CloudTaskRunModel, cls).get_export_policy(),
            **{
                'cloud_task_name': base_models.EXPORT_POLICY.NOT_APPLICABLE,
                'task_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,
                'queue_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,
                'latest_job_state': base_models.EXPORT_POLICY.NOT_APPLICABLE,
                'function_id': base_models.EXPORT_POLICY.NOT_APPLICABLE,
                'exception_messages_for_failed_runs': (
                    base_models.EXPORT_POLICY.NOT_APPLICABLE
                ),
                'current_retry_attempt': base_models.EXPORT_POLICY.NOT_APPLICABLE,
            },
        )

    # Here we use MyPy ignore because the signature of this method
    # doesn't match with signature of super class's get_new_id() method.
    @classmethod
    def get_new_id(cls) -> str:  # type: ignore[override]
        """Generates an ID for a new CloudTaskRunModel.

        Returns:
            str. The new ID for the CloudTaskRunModel.
        """
        return _get_new_model_id(cls)

    @classmethod
    def create_cloud_task_run_model(
        cls,
        cloud_task_run_model_id: str,
        cloud_task_name: str,
        latest_job_state: str,
        function_id: str,
        current_retry_attempt: int = 0,
    ) -> CloudTaskRunModel:
        """Creates a new CloudTaskRunModel instance.

        Args:
            cloud_task_run_model_id: str. The ID for the new CloudTaskRunModel.
            cloud_task_name: str. The name of the cloud task.
            latest_job_state: str. The state of the job at the time the model
                was last updated.
            function_id: str. The ID of the function associated with the task.
            current_retry_attempt: int. The current retry attempt for the task.

        Returns:
            CloudTaskRunModel. The newly created CloudTaskRunModel instance.
        """

        queue_id = CloudTaskRunModel.get_queue_id_from_task_name(
            cloud_task_name
        )
        task_id = CloudTaskRunModel.get_task_id_from_task_name(cloud_task_name)

        cloud_task_run_model = cls(
            id=cloud_task_run_model_id,
            cloud_task_name=cloud_task_name,
            queue_id=queue_id,
            task_id=task_id,
            latest_job_state=latest_job_state,
            function_id=function_id,
            current_retry_attempt=current_retry_attempt,
        )

        cloud_task_run_model.update_timestamps()
        cloud_task_run_model.put()

        return cloud_task_run_model

    @staticmethod
    def get_queue_id_from_task_name(cloud_task_name: str) -> str:
        """Returns the queue ID from the cloud task name.

        Args:
            cloud_task_name: str. The full name of the cloud task, which
                includes the project ID, location ID, queue ID, and task ID.

        Returns:
            str. The queue ID from the given cloud task name.
        """
        # The cloud task name follows the pattern:
        # 'projects/{project_id}/locations/{location_id}/queues/{queue_id}/
        # tasks/{task_id}'.
        # Therefore, the queue_id can be extracted from the 5th index.
        task_name_components = cloud_task_name.split('/')
        queue_id = task_name_components[5]
        return queue_id

    @staticmethod
    def get_task_id_from_task_name(cloud_task_name: str) -> str:
        """Returns the queue ID from the cloud task name.

        Args:
            cloud_task_name: str. The full name of the cloud task, which
                includes the project ID, location ID, queue ID, and task ID.

        Returns:
            str. The task ID from the given cloud task name.
        """
        # The cloud task name follows the pattern:
        # 'projects/{project_id}/locations/{location_id}/queues/{queue_id}/
        # tasks/{task_id}'.
        # Therefore, the queue_id can be extracted from the 7th index.
        task_name_components = cloud_task_name.split('/')
        task_id = task_name_components[7]
        return task_id

    @classmethod
    def get_by_queue_id(cls, queue_id: str) -> list[CloudTaskRunModel]:
        """Fetches all CloudTaskRunModels with the given queue ID.

        Args:
            queue_id: str. The ID of the queue to filter by.

        Returns:
            list[CloudTaskRunModel]. A list of CloudTaskRunModels with the
            specified queue ID.
        """
        return list(
            CloudTaskRunModel.query(
                datastore_services.all_of(
                    cls.queue_id == queue_id,
                    cls.deleted  # pylint: disable=singleton-comparison
                    == False,
                )
            ).fetch()
        )
